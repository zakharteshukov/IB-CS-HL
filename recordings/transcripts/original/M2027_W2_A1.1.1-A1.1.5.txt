So when you have different kind of task then CPU is much stronger than GPU.
It executes operating system instructions user commands and most applications logic prioritize flexibility and decision making.
So for general purpose CPU is used but GPU specialized processor which actually works on where the calculations are extremely.
Sorry built to perform specific types of calculations extremely efficiently focused on parallel processing.
Now this is the term parallel processing of large amount of data such as graphics rendering ideal for task with the same operation must be performed many times simultaneously.
So the major difference between CPU and GPU is that CPU is for different kinds of applications.
Whereas GPU is for same kind of task which needs to be completed faster.
Then comes the core architecture like you may have heard CPU is one core double core it's a four core CPU is a 16 core CPU.
So when you go and buy a new computer you will see on the specification that how many cores this CPU has more is the course higher will be the price.
Because CPU architecture is will be more advanced if there are more number of course but my question is let's say you buy a 16 core CPU and you buy a 3032 core CPU which will be faster.
If you have two options you go to buy a laptop the seller says that okay this is a 16 core CPU and this is a 32 core CPU which one do you think will be faster.
The 32 core sheets your course.
Okay so I'm sure that majority of you will think 32 core which is correct but there are conditions that number of course alone does not decide the speed of the computer.
There are many other things for example how much is the memory in the 32 core computer let's say you have 16 GB RAM.
Whereas in the 8 core CPU you have 64 GB RAM right so probably the 16 core CPU will work faster than 32 core CPU.
So there is a there is a threshold limit that you have many cores but can your RAM store that much of data to supply to 32 cores.
If yes then your system will be fast but you have 32 cores but the data which is coming is just enough for 10 cores then remaining 22 cores will always remain idle.
So in that case the efficiency of CPU will decrease.
So if you ever see a question that what are the factors that influence the speed of a CPU then you should say the factors include the core architecture for example how many cores.
Then it also depends largely on the on the primary storage and it will also depend on the bus bus speed.
So how much data can bus transmit during the fetch decode executes cycle so everything needs to be synchronized for the CPU to work perfectly.
If anything is too high and something is too low then your CPU will not give the optimum solution optimum speed.
Then GPU core thousands of smaller simple cores each core is not as powerful as CPU but together they perform massive parallel computations.
This parallel is the keyword so you have to be mindful about that so whenever you talk about GPU say thousands of CPU core which are working parallel for parallel computation.
And then the example they are good for image rendering and all that memory access so these are different see what we are studying right now is about the difference between CPU and GPU in terms of design in terms of number of course and in terms of memory access so you need to know all three parts and even power efficiency.
Definitely CPU will consume less power because there are less cores whereas GPU has so many different cores and every core requires some electrical pulses so the electrical power needed for GPU will be much higher than the CPU and that is why you may have heard that for the AI servers to work they consume a lot of power.
Like if you use let's say chat GPT or per perplexity to even generate a small image the amount of electricity that CPU will take or the computer will take would be as good as let's say one unit of electricity it consumes a lot of power because there are so many tiny processes which are working and they need power.
Practical application for CPU and GPU we have talked about this so let's move to the next one how okay there's another model which is hybrid don't think that if one computer is based on a CPU architecture and one is based on GPU architecture they can be two different architectures in two different laptops that's possible.
But then to get the optimum user of your laptop the new machines actually come with a combination of both which is called a hybrid model so your CPU will be single double or or four course or six course and then also you will have the GPU installed into that so depending on the nature of task if you are doing the video rendering that will go to the GPU if you are doing normal processing that will go to the CPU so they will know which application is to be run by them and accordingly they will be able to do it.
Make a decision and that will make your system more and more efficient imagine a system which is just which just carries a GPU it will not be very efficient for different kinds of task it will rather go slow and if you are using CPU and if you are doing video rendering again it will be slow but if you have use a hybrid model then together they will be able to decide which CPU or GPU will take up the task and it will become much faster.
So the new computers have the flexibility of having both working simultaneously.
Then we have the practice questions from this topic then we have the purposes of different memory types now this is something which you have been studying from your childhood time I'm sure.
What is the difference between RAM and ROM so essentially there are four types of memory RAM ROM cache memory and registers we already talked about the registers they are only they are embedded into the CPU what is the what is the RAM and ROM.
Those who have studied computer science in grade eight nine ten they should know what is RAM and ROM.
Well, the random access and memory holds all the data and instructions for the programs that are currently in use currently running let's say a various redone memory well as far as I remember it's basically for it's used with bios of the computer like it stores.
The instructions for the initialization of the computer and also it transfers the software data the software application data to the computer well as far as I remember yeah.
Like if you want to set up the windows you will have fresh first go to the bias and upload from the secondary memory the software to the computers.
I can only give you a round of applause guys this is and this is an excellent answer and she has covered more than actually what I expected so.
As you can see that the RAM and ROM both are used for storing information and as the software rightly said RAM is the memory which actually holds the data which is currently being executed by the CPU now imagine a scenario that you want to let's say play a game.
Now the game is stored on your hard disk or it is in the cloud now when you access that game that game goes to the RAM and from RAM it goes to the CPU so RAM is a temporary memory which stores the data temporarily while the CPU is executing it it is a volatile memory volatile means it will lose the data if you turn off the computer because it's a temporary memory.
It will also flush itself out when the application execution is finished so that the other applications can come and get some space in the RAM however ROM is basically a permanent storage which contains most of the system files which are needed for the smooth functioning of the computer.
So as a software user word bios basic input output system those softwares are stored in the ROM and they are very helpful in the booting process so when you start your computer the operating system roll comes little later but before that the start of files are stored in the RAM read only memory.
Okay it is embedded into that and we cannot delete it whether computer is turned off or like how we delete files in the hard disk we cannot delete the data in the ROM under the normal circumstances and if your data gets corrupt in the ROM then there is no way that your system can start because ROM contains the special system files which checks everything related to the system that is RAM working fine is input and output devices connected to your computer it will check the power.
Input and output to different components so all the initial checkups are carried by the ROM and these are free pre-feated instructions which are inserted into the ROM by the manufacturer.
So if you are buying an Apple computer the ROM chip will have the instructions feed by the Apple computer if you are buying let's say Samsung or Acer they will make the ROM filled with the instructions which are needed for the running of the operating system.
It also contains lot of other things like for example when you switch on your mobile phone you see the logo in the beginning now that logo etc everything is stored in the ROM and it is unchangeable you cannot change them what is embedded into that that stays there forever.
So that's about ROM permanent instruction non-volatile and we can't even delete it I mean you need special software to delete the content of the ROM and why will we do that because why do you want to fiddle with system files which may impact the functionality of your computer.
Then comes the cache memory which sits in between the RAM and CPU and cache memory is also I mean you have two options either it can be embedded within the CPU or you can have a separate chip also for cache.
Depending on what computer you have procured now the benefit of cache is that it is a super fast memory it is much faster than RAM and ROM and it is very close to the CPU.
So from hard disk or cloud the data goes to RAM from RAM it goes to the cache memory and from cache memory it goes to the registers and from registers it goes to the CPU.
And because the cache memory is made up of material which is very fast in nature so the CPU's ideal time is reduced if the data comes to the cache memory.
Cache is a new concept the old computers did not have it like if you talk about if you look at the computers which were manufactured in 1995 to year 2000 that was the time when the cache memory started to emerge but before that the computers didn't even have them.
So each type has a distinct purpose contributing to efficient CPU operation so every new innovation is actually possible because of these changing trends in the technology.
When we'll study about the hard disk or the secondary storage device you will see how we have progressed from magnetic disks to now the most recent SSDs and how the speed has become better and better with the new technologies.
But that is not the part of this topic so we'll study that later.
Then it's further details about RAM volatility impact on performance more RAM allows more programs to run simultaneously without slowing down.
So if your computer is getting stuck if you run few applications that means your RAM is not able to take all those applications and if you increase the RAM of your computer probably it will become slightly better in terms of speed.
But then your CPU should also be able to handle that much of data.
In smartphone switching between apps is quick because apps remain in RAM until close or replace that you know that RAM keeps the data until either you turn off your phone or the processing of an application is completed.
So let's say you have an application which is currently being executed by the CPU that stays in the RAM as soon as the CPU gets the instruction from program counter that the application is done.
The operating system will pull that information out of the RAM so that the space is created for next application.
So all that switching is actually done by the by the operating system.
Then we have the ROM BIOS basic input output system or a form where which runs self tests and loads the operating system when the device is powered on.
ROM is non-volatile so it retains the data even when the power is turned off modern variation many computers now use flash memory a form of ROM that can be updated for example BIOS updates.
This is a new enhancement in the ROM where even though it is non-volatile it cannot be deleted but then there are ways that the system itself will download the latest updates and it will update the BIOS.
It may not be possible for us to do it manually but the architecture of the system could go into the BIOS and updated and that is called the BIOS updates.
You may also have seen on your mobile phone sometimes you get the updates and it says that it will update your BIOS whether you agree or not and if you say yes it will go and update it.
On a phone ROM stores the operating system so it is always available during the startup.
Now the cache memory it acts as a middle player as I said between RAM and CPU from the
instructions data so that CPU can avoid fetching them repeatedly from RAM so instead of going all the way from CPU to RAM now there is an intermediate cache memory which is much faster in data transmission and it is much closer to the CPU.
So the data goes from RAM to cache memory and from cache memory to the CPU for the faster execution and there are different levels depending on the size how much data it can hold L1, L2, L3 and most recent L4.
No L3. L3 is the latest one which can store up to 2 MB to 6 to 64 MB.
Okay then another thing the number doesn't mean that it is fastest as you can see here L1 cache which is smallest but it is fastest.
Look it directly on the CPU code often split into instructions L1i and data L1d cache.
L2 this is the capacity slightly slower and L3 and this could be one of the tasks that you may do that how come a small 32 kb is faster than a large 64 MB cache.
You can take this for further research to find out the reasons why it is so.
Okay cache hit a cache hit is basically a process where CPU may be working at a certain speed and if CPU wants to fix some data and it finds the data as soon as it contacts the cache memory that is called a faster way of accessing which is the cache hit if the cache hit is higher that means the CPU is working faster.
And cache hit means CPU is ready to process the data but when it goes to the cache it doesn't find any data so that means the cache the CPU has to wait for some more time.
After waiting for some more time it goes again and it finds the data so but there was some delay time there was some delay so that will slow down the machine.
So you may remember this cache hit and cache mess in terms of the efficiency of the CPU.
Cache notes on your desk RAM books in your room and hard drive library across town who do you tell me about this analogy what it means.
I want one of the boys to speak what is this analogy hello hello hello yes sir go ahead.
The way I would think about this the fact that since the cache is so easy to locate at but only contains a small amount of information it kind of works as sticky notes and that.
As RAM which is a little slower to access but it still like not at all as much information as you can locate in your hard drive would be like a bookshelf in the room like very close by but.
Small amount of information compared to the hard drive which is a gargantuan amount of information or far away.
Thank you for that contribution and I completely agree this is a scenario as I said that first come hardest then comes RAM and then comes the cache and if CPU has to pull the data obviously cache is the closest one so it can pull it faster.
Now think about a library kind of scenario you you are in the school and you have the library you have the library little far from your classroom which has the book that is first scenario.
Now again the book is kept somewhere in your room and third scenario the book is right in front of you on the table and you want to access the book obviously the book which is on your table would be accessible at the most fastest way right that is what is cache memory.
The cache memory is very close to the CPU so the CPU can easily fetch the data the next level is RAM so the book is in your room so you have to get up go and get the book which will be little time consuming.
And the third which is hard disk is the library far from your room so you have to go all the way to the library to pull the book so that defines the speed at which you can access the book.
And then we have different types of registers for example the program counter we talked about that we have the instruction register which stores the next instruction which is to be executed.
Program counter counts how many are done MDR we have done AC we have done registers allow the CPU to execute instructions are maximum speed by avoiding delays from the RAM size very small in capacity measured in bytes or words but critical for efficiency.
A CPU can work even without registers but then the whole dependency will be on the RAM so it has to go all the way to the ramp for every fetching that will slow down the speed.
And then we have these practice questions so you may take them up in your free time and try to solve them.
Last topic for today is the fetch decode execute cycle and who shared with us fetch decode was it nano.
Was it nano who talked about fetch decode yes yes okay right so nano your favorite topic we are getting on to fetch decode executed CPU gets the instruction from the memory decode it interprets the instructions and executes CPU performs the required action and fourth stage which is generally not talked about but that is storage but you don't have to study that because that's not in your course.
So essentially you have to think about these three stages fetch decode and execute the registers which are involved in this whole process is program counter MDR instruction register and accumulator so you should know what they are and what do they work like Sophia mentioned about MDR and MDR that one looks for the address and MDR goes there to pull the pull the data and then we have the buses which actually actually carries the data.
This cycle repeats continuously as long as the computer is running.
This is also sometimes called instruction cycle so don't get confused if you see the word instruction cycle it's same as fetch decode execute.
Okay now this is the algorithm which is followed and when we will do the programming I will ask you to write this cycle in the form of a Java program.
So please get yourself familiar with how the fetch decode execute cycle works.
So program counter what it does MDR what it does reading signal memory data register instruction cycle and program counter these are six or seven stages which you should be familiar with and I can guarantee you that in your DP exam you will have minimum four to five mark question based on this these stages so this very important.
Then above decode what happens in the decode so CPU the control unit interprets the instruction if it is an algorithm arithmetic operation it signals the ALU.
If it requires data from memory it sets up the MDR and MDR if the control operation like branching it adjust the program counter so that is what happens in the decode stage essentially it's identifying the nature of the task and activating the related component of the computer.
The decoding process ensures that CPU understands what is what the instruction means before execution so it also converts the data into machine readable format so two things are happening here.
One is CU interprets the instruction and second the decoding of the instruction is happening then comes the execution cycle and there are roles of CU ALU and accumulator which you should be aware of.
This is a very important topic I am repeatedly telling you and this is an example given which is from the assembly language as to how the instruction of data needed this is just additional thing I mean for your understanding you can read this but this will not be asked as to how the fetch decode execution works what is important is this part this whole thing fetch decode and execute.
Importance of cycle why is this cycle important so that's about fetching the instructions and then executing them so similar to this document we will be creating the documents for each week that you are covering and this will be in addition to what you already have on the palm of your.
But both Martin and I would like to strongly recommend that if you want to get best benefit out of these classes then please come prepared take some inspiration from Sophia she is very well prepared for she was very well prepared for today's lesson and you saw the responses the quality of responses and few others like nano and few others so part actively in the classroom.
So we don't really want to make it a teacher oriented lecture but we want to make it more like a discussion with each other because honestly see computer science is not an easy subject I'm telling you again and again it's a very difficult subject but if you are developing a good understanding week after week then probably you will be able to manage it quite easily.
All right, so I will give you five minutes time to ask any questions if you have or any other difficulties about the LMS issues or accessing the video any any other issues that you want to discuss.
We can find this document.
Okay, thanks.
Okay, who would like to answer this question, where can he find this document, who remembers.
Who remembers where this document can be found from.
Okay, Luis, where can you find this document? Louis.
It wasn't about document but when you were mentioning about ROM I found it interesting that I need a connection because something that I remembered.
Because there is a Linux based operating system that it called sales OS that is known for giving it total anonymity when or at least it gives it any of how you use it and it runs purely on RAM so one of the objectives based on this operating system is generally any trace in your system and trace of quality.
So it makes totally sense now that you connect with the rent and how it's based on temporary so.
Absolutely interesting.
Yeah, true and every operating system has its own own way of handling the RAM like how it works on Ubuntu, which is on Linux, which is a Unix based system would differ from how it works in a Windows based system.
So every operating system has its own architecture as to how it does the time slicing.
I don't want to go into the depth of those techniques otherwise we'll confuse some students but then every operating system is capable of handling the RAM in different ways.
The whole objective is to make the efficient use of RAM so that the maximum applications can run simultaneously.
All right, so nobody knows where to find our document.
Let me show again.
It isn't the files you've shared on by your point if you can look there it's in the direction exactly so.
If you if you go to the document which is shared with you on the share point where you find the recording in the same folder you will find this PDF also.
Oh, I don't know where to find the recording.
You can find the recording.
Okay, so you're in excel section right.
I mean, HR.
You're in excel.
Okay, just drop us an email.
We will reshare the folder with you.
So where can I find the folder?
You if you actually be sent an email to you, you may have received an email from share point inviting you to reset your password.
Okay, if you haven't, if you haven't, have you got that?
Yes.
So there's a link that access the folder.
So when you click on that, it will send you a OTP one time password and then you have to enter that to access the documents.
I will share this presentation also with you, which is a shorter form of the larger document that you just saw.
So it's just a summary of points.
But since we have only created it, so I don't mind sharing it with you.
So this will be good for revision purpose.
Okay.
Before we pray, do you want to do a coward quiz?
Are you find going in for a coward?
Yes, Martin, my question. Sorry, Martin.
No, I'm sorry, is that.
Gea is saying that she cannot talk that she has some questions and it looks like several students still have a lot of issues connecting.
Jacida has a lot of issues.
She has sent a couple of emails.
What I can say is that I will take a look into what the issues are and we'll try to answer your questions through the way.
Yeah, sure.
One second.
Yeah, and some people don't can access the folders still.
Ueis from the SL section and they cannot access the folders with the documents.
Okay, okay.
So I will share the will create a folder and share the links with them.
I think I created a quiz for this chapter.
Let me see if I can find that.
While you find it, I have created a slide for a PowerPoint kind of to help them understand the fish, the code and execute.
I don't know you to go over that.
But if not, then we can do that.
Maybe we can we can do in the next next lesson.
Maybe we'll start with fetch to code execute cycle and then we'll move to the next.
But we can share that we can put that document a presentation in the folder and.
Okay.
Okay, guys, let's do.
Is there a question somebody asking question?
Yeah, I didn't get an email from this share point.
Okay, so just drop us an email, drop an email, we'll make it for you.
Okay, could you join this game?
What is 64 007?
Those who don't know which link to go do I put it in the chat?
I can see only 15 have joined can others also join.
19 20.
Okay, so I'm starting the game, respecting everybody's time.
So we start.
There are 15 questions, but maybe let's see how it goes.
I will stop it either at 10 or otherwise we will.
Okay, so I can see a mixed kind of response.
Some of you said instruction registers.
Program counter is the one that actually holds the address of the next instruction.
So that's the correct answer program counter.
So if you read the definition of program counter, it holds the address of the next register, which is to be executed.
I are keeps the at the instruction, which is currently being executed.
That's the difference.
So it's a tricky question, but PC is the correct answer.
So we have Ricardo on the top, Louis and Namo.
This should be all correct.
Okay, so one of you felt a control unit.
Now it's arithmetic, but 15 have given correct answer and some of them.
I think did not answer anything.
So majority set see ALU, which is good.
Ricardo, Namo and Louis.
Main function of the control unit.
Okay, so 13 of you felt that it's direct data flow, which is good.
If you said perform logical operations, no, that is the work of a component of CPU, which is algorithmic and logical unit.
But control unit directs the flow of data and instructions.
Louis is heading up Namo is third and Ricardo still maintaining the top position.
Okay, so majority of you said control bus, which is the correct answer.
So it's not data bus because data bus actually carries the data address bus carries the address.
But what is to be done is controlled by the control bus.
Louis gone down Alexa has come up Namo still on number three.
Instruction register. Yeah, that's the correct answer.
There was a confusion between a accumulator.
Accumulator does not hold the instruction, but it holds the temporary results after the calculation.
MDR holds the address program counter holds the address of next instruction.
And IR is the one that holds the fetched instruction, which is to be executed.
Okay, Ricardo number three and Namo is on the top followed by a new name Ben on the second position.
Sequential task.
I knew that some of you will say GPU, but it says for the sequential task.
So which is a single core CPU because the whole efficiency of the CPU is dedicated to the application.
So single core CPU is the right answer. Alexa going up Louis Ricardo coming back to the frame.
Panel task.
14, yeah, so majority of you said for a GPU. Some of you felt co processor.
No, co processor concept if you recall that is something different.
So GPU is the one which is specialized in parallel tasks.
So that means you have to go back and read about what co processor does.
Unchanged Namo on the top now.
Why is GPU faster for AI training?
Perfect, so majority of you said many parallel course, which is good.
Unchanged.
This would be all correct.
Okay, so two of you felt it's ram. No, ram is not non volatile.
Ram is volatile memory.
Then two of you said cash. No, we are saying firmware firmware is the special system software, which is stored.
Performantly so it's it's wrong read only memory.
Okay, Ben gone down Alexa going up and Louis on the third position.
Fastest birth smallest.
Okay, so I anticipated that many of you will say cash memory, but no registers is the smallest memory, but the fastest because it is embedded within the CPU.
So registers is the fastest and smallest cash is not smallest.
Okay, course remains unchanged. I'm sorry, the ranking remains unchanged.
What is the cash hit?
Data found in the cash that is the cash hit and cash misses when data is not found in the cash.
Okay, we have Jay seal coming up software in the frame after long, long time and number on the top.
All right, so many of you felt it's decode. No, after the decoding is a bit step of cycle places the instruction into the instruction register.
So it's the fetch, fetch cycle after which the data goes into higher and then it is decoded and then sent to the memory to the CPU.
Cash SL going up on number three, we have three more questions.
What does the CU do?
All right, so majority of you know it interprets the instructions that the correct answer.
You felt runs the program and one of you said fetches data.
One said source result. No, the role of CU is to interpret instructions.
Okay, so no changes in the rank.
Which stage of the cycle automatic actually runs the instruction.
So majority of you said execute, which is correct. One of you said decode. No, the decode does not run the instruction decode it decodes it and then gives it to the CPU, but execution is the site stage when the program is run.
I think last question. Yes, all the best.
Until the CPU is turned off that fetch decode execution cycle keeps on repeating.
So let's see the podium. We have on number three.
Alexa, good work, Alexa.
We have just still on number two and we have on the top position.
Well done guys, this is lovely.
And then we have Ricardo and Sophia who was leading for a very long time Ricardo, but well done everybody.
It's really nice. Nice to have seen your performance in the quiz.
Okay, so with that we come to the end of today's lesson.
The recording will be made available in the folder most likely by tomorrow.
So tomorrow evening, if you go to the folder, you should be able to see the recording.
Any questions before we leave.
For the share point, you just drop us an email and we will reshare the link.
Even if you have any other queries, the best way to reach out to us is by writing to us.
Otherwise, when we meet during the weekly meetings, that is also the time when you can actually discuss your problems.
So I can see that some of you are saying that you had difficulty in clicking the answers.
That's okay. It was just a game.
If nothing else, Martin, do you want to add something or we just.
Now we're good. I think we have a good class today.
I hope you enjoyed guys and let's get the best benefit of these classes because we are making an extra effort.
To have these classes conducted. This is not really something that is expected from us.
Because Parmoja works in a slightly different manner.
It's not really expected from us, but we want to see you as successful candidates for the for this ID computer science course.
So we are willing to go an extra mile, but you also have to take an initiative and get best out of it.
Malaria, you have a question or.
Thank you.
Thank you. Thank you. Thank you all. We appreciate your time.
Good luck and have a good day. Bye. Bye everyone.
Bye guys. Have a great rest of the day. Bye.
Thank you.
Sure. Bye everyone.
Thank you so much. Bye.
You're welcome. Have a good day.
All right. Okay.
Thank you. Bye bye.
Martin, you want to come on.
Martin, you want to come on teams?
I will just create a meeting.
Yeah, go ahead and do that.
Okay. I'm going to leave here.
Yeah, sure.
