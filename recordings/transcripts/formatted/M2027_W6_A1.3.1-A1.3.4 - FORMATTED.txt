IB COMPUTER SCIENCE HL - WEEK 6
A1.3.1-A1.3.4
Transcription - Formatted

================================================================================
LESSON OUTLINE
================================================================================

MAJOR TOPICS & THEME SHIFTS:

1. CLASS INTRODUCTION & WEEK CLARIFICATION
   - Week number clarification (Week 7, not Week 6)
   - Brief administrative check

2. INTRODUCTION TO OPERATING SYSTEMS
   - Definition: OS as bridge between user and hardware
   - Core purpose: Control, supervision, and resource allocation
   - Abstraction concept (data abstraction, hiding non-essential parts)
   - OS in various devices (computers, mobile phones, smartwatches)
   - Simplified environment for users and developers

3. KEY ROLES OF OPERATING SYSTEMS
   A. CPU Management
      - Process scheduling and task allocation
      - Context switching and multitasking
      - Priority allocation
      - Pipelining and reducing CPU idle time
   
   B. Memory Management
      - Primary memory (RAM) vs Virtual memory
      - Memory allocation and re-allocation
      - Paging and memory division
      - Dynamic memory management
   
   C. Storage Management
      - File systems (NTFS, FAT, APFS)
      - File organization and indexing
      - Directory structure and metadata
      - File operations (create, read, write, delete)
   
   D. Device Management
      - Device drivers and plug-and-play
      - Spooling (printer example)
      - Buffering (video streaming example)
      - Interrupt handling (printer out of paper example)

4. TYPES OF OPERATING SYSTEMS
   - Command Line Interface (CLI) / Command User Interface (CUI)
   - Graphical User Interface (GUI)
   - Touch Interface
   - Historical evolution: CLI → GUI → Touch → Future (virtual screens)
   - Comparison and use cases

5. MODERN OPERATING SYSTEMS EXAMPLES
   - PC Operating Systems: Windows, macOS, Linux
   - Mobile Operating Systems: Android, iOS
   - Server Operating Systems: Windows Server, Linux
   - Embedded Systems: Real-time OS for IoT devices, cars, medical instruments

6. DETAILED OS FUNCTIONS
   A. Memory Management Details
      - Loading programs from secondary storage to RAM
      - Memory pages and sections
      - Dynamic re-allocation and freeing memory
      - Virtual memory usage scenarios
   
   B. File Management
      - Hierarchical directory structure
      - Unique file naming and extensions
      - Access permissions (read-only, etc.)
      - Defragmentation process and purpose
   
   C. Device Management Details
      - Device driver installation
      - Buffering, caching, spooling
      - Plug-and-play functionality
   
   D. Scheduling Approaches
      - First Come First Serve (FCFS)
      - Round Robin algorithm
      - Process queues and CPU time allocation
   
   E. Security Management
      - Authentication (password, biometric)
      - Windows Defender / Mac security features
      - Third-party app warnings
      - System file protection
   
   F. Additional Functions
      - Accounting (resource usage tracking)
      - Virtualization (running multiple OS simultaneously)
      - Networking (file sharing, network connections)

7. ADMINISTRATIVE MATTERS
   - NetBeans and JDK installation instructions
   - Operating system information collection (Google Doc)
   - Assignment review discussion
   - Video recording access instructions

8. INTERNAL ASSESSMENT (IA) DISCUSSION
   - IA Timeline Overview:
     * November 5: Introduction to IA
     * November 26: Introduction to Criteria A & B
     * February 11: Criteria A & B due
     * April 25: Criteria C due
     * September 9: Introduction to Criteria D
     * November: Criteria D first draft
     * February 24: Final IA submission
   - IA Requirements:
     * Criteria A: Problem specification
     * Criteria B: System decomposition
     * Criteria C: System design (UI, algorithms, flowcharts)
     * Criteria D: Product development (1000 words + 5-minute video)
     * Criteria E: Evaluation and future recommendations
   - Programming language choice (Java, Python, or any language)
   - Justification vs. complexity requirements
   - No client requirement in new guide

9. Q&A SESSION
   - Questions about IA requirements and timeline
   - Programming language clarification
   - Java learning for Paper 2 (not just IA)
   - Assignment grading questions
   - Video access questions

10. CLOSING REMARKS
    - Upcoming topics: K-maps, logic gates, truth tables, Boolean expressions
    - Course structure: Mix of theory and programming
    - Future units: Computational thinking, databases, networks, machine learning

MAJOR THEME SHIFTS:
1. Introduction → Core OS Concepts (Definition & Abstraction)
2. Theory → Practical Examples (Real-world applications)
3. OS Functions → Detailed Technical Explanations
4. Technical Content → Administrative Matters
5. Main Lesson → IA Discussion
6. IA Discussion → Q&A Session
7. Q&A → Closing Remarks

================================================================================
CLASS INTRODUCTION & ADMINISTRATIVE MATTERS
================================================================================

This is week seven, right?

I don't know why I'm thinking always it's week six this week seven.

So if you could just spend 30 seconds time to read through what an operating system is, nothing different than what you just mentioned.

It provides a bridge between the user and the hardware.

That's the key term.

Ensuring that all components of the computer work together efficiently, securely and reliably.

So there has to be a control.

There has to be a control system within your computer, which could actually oversee all the functionality of your computer that the resources are properly utilized.

They are shared between different applications.

The user is able to run the applications which they want.

There is enough memory available to store all those applications.

So there has to be a control.

There has to be a supervision of all these tasks and that supervision and that monitoring and that allocations is basically the role of the operating system and operating system is not just for computers operating system could be for mobile phones.

It could be in your smartwatch any digital device essentially has an operating system, which actually does that work either for the computer or other digital devices.

So without an operating system, users would not be able to interact directly with the hardware using complex machine code instructions.

The OS hides the complexity by providing a user friendly interface and standardized service for applications.

What is this term called an object oriented approach when the non-essential parts are hidden and we only see the things that we want to see.

There is a term which you will study about when we will start computational thinking, but can somebody recall that word.

Abstractation.

Yeah, absolutely.

So data abstraction is the one of the features of object oriented programming, which gives you the flexibility to hide on essential things and should be able to see only what you want to see.

So when I'm looking at my screen right now, there is a lot of things which is working the background, but it is hidden from me and that who is doing that actually the operating system is doing that.

So these are some very basic things about OS.

It provides you a simplified environment for users and software developers.

Okay, key roles of the operating system, CPU management.

Now in the previous units, we studied about the CPU and how it works.

CPU may be working independently, the work of CPUs to get the instructions decoded, executed and then give the results back.

That is the whole work of CPU.

Now, how is that CPU going to work?

The CPU is controlled by the operating system in the sense that operating system will decide which task is to be given to the CPU.

What amount of what size of data needs to be given to the CPU?

What sequence it is to be given to the CPU?

All that will be decided by the operating system through its architecture.

And CPU role is not to decide what should come next and what should go next.

The role of CPU is to just get the data executed and give the results.

But that transaction of data between the hardware between the storage device and the CPU that is taken care by the operating system.

Somebody's microphone is on.

Could you please turn off your microphone?

The one who is typing right now your microphone is on.

Martin, who is that?

Can you identify?

I don't know.

I'm trying to give access to some of the kids today.

Share folder.

They're just in texting me.

Okay.

Okay.

So the OS decide which processes use the CPU and for how long it manages process scheduling, ensuring fair and efficient CPU time distribution among running applications.

So we saw in the previous class about the pipelining process wherein how best the time of the CPU can be utilized with an intent to reduce the ideal time.

The more ideal time CPU gets, the slower the processes would be.

So operating system.

Plans the task allocation in such a way that it gives least ideal time to the CPU so that even while one instruction is getting executed.

The operating system will make sure that the next instruction should immediately be ready in the instruction register IR so that the moment first is done.

The next instruction goes for the processing.

So all the scheduling is done by the operating systems.

It handles context switching allowing multiple programs to appear as if they run simultaneously, which is multitasking.

Can somebody tell me what multitasking is?

That is one of the strongest features of a good operating system that it facilitates multitasking.

Could somebody explain what this means?

It's doing more completing work.

Yeah.

Yeah, multiple tasks at the.

Yes, so it's kind of simultaneous execution of applications at the same time.

Although it may look like we are running multiple applications together.

Like for example, right now my laptop is doing so many different processes.

It is capturing my voice.

It is capturing my video.

It is running browser with the so many tabs open.

So many things are going on and it may look as if every application is running independently, but it's not so.

It's the process of scheduling.

The CPU using one of the algorithms would dedicate time to each application in a sequential way in such a way that it will give some time to my voice.

Sometime to my video sometime to the application and then it will return to the first application.

But that circulation is so fast that we feel that everything is going together.

So this is another feature of an operating system that it is able to run multiple applications or depending on what capacity of computer you have.

What is the memory size?

What is the CPU capacity?

Accordingly, the operating system decides how many applications it would like to give to the CPU so that user gets uninterrupted experience.

Like here is an example.

When you listen to music while browsing the web, the OAS locates short time slices to each process so that both of them run smoothly.

So this is example of just two, but it is actually doing a lot of other things.

Few things which we are doing and few things which are running in the background.

For example, running anti-virus, making a backup and many different things which are going in the background, which we don't even know and it's not meant for us.

But the operating system actually keeps track of all those processes and is giving time to them so that everything runs smoothly.

Now, also there's a priority allocation.

For example, if there's a background work which is not directly meant for the user, the operating system based on its architecture may give that least priority.

That is a background work which may continue even later, but right now the more priority should be given to the ongoing call so that there's least interruption between what I'm talking and how you're able to listen to me.

So we'll study about that prioritization and many different approaches that operating system use.

Now, memory management is one of the most important features of operating system and it's important in the sense that the modern day computers are able to run many different applications because the CPUs are very powerful.

There is a lot of storage available, so which means the operating system needs to be more efficient when it comes to be to the memory management.

Now, depending on the memory size that you have in your computer, if you're running the number of applications which can be accommodated easily within the primary memory like your RAM, then it will not require any kind of virtual memory because your primary memory is big enough to hold all the applications which you're running.

But then if you talk about the old computers or even in the new computers, let's say you're running some application which requires more memory than what you already have, then the CPU will not just crash your laptop or close the application, but it will use a virtual memory which is part of your hard desk.

So it will allocate some fixed space on your hard desk which will be dedicated to the operating system for switching any task which is beyond the size of your RAM.

So imagine your RAM is let's say 120 GB, 28 GB and you're running an application which is which requires 300 GB every cycle.

Now, operating system cannot say that no, I will not run this application because you don't have even enough memory.

So what it will do after those 128 GB is filled, it will then shift rest part of it to the virtual memory which is the part of your hard desk and it will then RAM plus virtual memory on your hard desk will work as a cohesive unit.

So collectively it may become 128 plus let's say one TB there so one TB and 128 GB becomes one primary memory.

But the virtual memory control goes under certain circumstances like when the RAM is not able to fulfill or there is something called.

There's a term it starts with P I'm not able to remember that proximity it's something like that.

That is the process wherein if you're running some sort of application let's say you're doing some research on genetic data which has millions and millions of records.

Now none of the RAM can actually complete that process in one cycle.

So which means in that case this virtual memory plays a very important role so it will process some part of the data and it will extract the result out of it and keep it in the virtual memory safe.

So that even if you turn off your computer next time when you turn it on and your process starts from that point onwards it will still be able to fetch that information from the virtual memory.

So essentially we say that the primary memory is temporary but in that particular scenario your virtual memory will be able to retain the data until it is until that application completes its whole process.

Otherwise what will happen is let's say you have spent three hours running some application okay it has given you some result that result is needed for the next process and if you turn off your computer then everything is gone.

So in those scenarios that result is kept comfortably in the in the virtual memory which stays there even if you turn off the computer and that will be erased only when your entire processing is done.

So all these kind of arrangements are actually taken care by the operating system.

So this is same when many tabs are open the memory separately preventing one tab from crashing others storage management.

So every operating system maintains a specific kind of file system file system is nothing but it's kind of indexing and the way the files are stored on the secondary storage device.

Like for example this NTFS does anyone know what is the full form of NTFS?

It's Windows perhaps.

Yeah so what is the full form the full form is?

What is the full form?

Good question.

Anybody else know this Windows?

Your file.

Yeah technology file system.

Yeah correct new technology file system.

This was launched much later before this was called FAT file allocation table which was used again in the windows which is also used in the in the Mac operating system.

So if you actually go to the.

What is the command in Mac where we can see the partitions?

What is that called?

Not terminal.

Not good campus.

Where do we see the partitions in Mac?

There's a command for that.

Disk utility.

Yeah if you go to desk utility utility here you can see.

Like for example if you want to look at the partition.

If for example I want to.

Somebody's a microphone is on could you please turn off could you please check your microphone it's very irritating.

So basically I'm what I'm looking for is which I'm not able to find that if you try to.

Format your PC or you want to make for the partitions it tells you what kind of.

Partition you want to make is it FAT or.

And.

F S.

Geo ID partition map.

Okay so it's showing here some partition APFS.

This is probably the one which is used by the Mac.

So if you do further research about it APFS that is a partition which this is using.

But I know that it also uses FAT is so file a location table is one also one of the.

Partitions that was used by the Intel chipset I'm not sure about the Apple because I've never tried it.

So if you try and insert a pen drive and you try to format it using this disk utility.

It will show you different formats in which you can format it using FAT and anti FS etc.

So these are different file systems which are used by different operating systems to basically organize the.

Files how they are placed in the desk and how the system can retrieve them whenever they are to be retrieved at a later stage.

It handles file creation relation reading and writing keeps directory structure and metadata like file size creation date etc.

So whenever you create any folder and you try to save them on your desk it will always keep you.

It will always give you the flexibility to.

We able to see the info about them for example if you go to info.

Get info it is able to show all the details about this file what is the size how many.

Files are there within this folder when was the when was this created what date what time.

And besides that also there are a lot of other things like metadata name of the author and many different things.

So for every file these details are maintained by the operating system and it is done for a simple reason that whenever you want to retrieve the data.

It works like a it works like an index page like how you have index page in the beginning of every textbook.

It helps you to jump to a lesson by looking at the page number that okay page 78 is chapter number seven.

So you can directly jump to chapter number seven.

So similarly operating system also when it stores some file it stores its identity into file a location table or an TFS or whichever format it is using.

So the next time when you try to open that file it will go to that index and it will try to retrieve the data.

So when you store a word document it decides where on the disk it is going to be stored.

Then the device management this is the next feature about the of the operating system that any device that you connect to your computer.

Your operating system is the one which is going to utilize that okay.

Now in the new computers we don't require installation of drivers because the new operating systems are well equipped with many different devices which you connect to them.

So the moment you connect it's called plug and play like let's say you connect a external web camera.

You don't really have to install it because the moment you connected it will be able to plug and play but in the old computers like you can talk to your parents if they use computers before.

Every time that we bought a new device for our computer it used to come with the device driver in the form of a CD.

So whenever you buy a new device a webcam or an external keyboard or anything which was not part of the computer or a sound card graphics card.

We had to install the driver with it and that driver would indicate to the operating system as to how that device is to be used.

So if you just plug in a device it will show an exclamation sign in the device manager that this device is not recognized.

The operating system knows that there's an external device which is connected but will not be able to understand what it is meant for.

When you install the device driver that will indicate to the operating system that what this device is and how it is to be used and then you will be able to use it.

So even if you connect a new printer it won't print until you install the driver.

That is the role of operating system to manage all the devices which are connected into the computer.

It coordinates communication between hardware, printers, keyboards, USBs and other applications.

And then it uses techniques like spooling, buffering and interrupt handling.

Could somebody tell what spooling means?

What is spooling?

It's the Q in.

Yes or data?

Is the Q of your correct any example where you can say that the work is getting spooled?

Can you give an example of spooling?

Maybe.

Maybe one we in the printer example.

Yeah, one particular sequence of pages.

Well, it's being cute.

And one page brings after another.

That's a good example of spooling wherein if let's say you give a command of a PDF document which is 20 pages in size.

So when you give the command from your laptop and it goes to the printer in the printer printer's memory, it is pulled.

And it will start printing page after page.

So it prints first page and then the spooler will release the next page and that process will continue to go until all the pages are printed.

This is also something called a Q.

There's a very thin line difference between a Q and a spooling.

Spooling is basically storing the data until it is completely executed for example printing 20 page document.

There's another thing which is called Q for example.

Let's say there's a network printer and three different people have given the print commands.

So while the first person's printing is happening through the spooling, the other two will be in the queue.

So only when your first printer first person print is completed, then the queue will be released and next person's turn will come that is called a queue during of the applications.

The next is buffering.

What is buffering actually?

We often use the term buffering.

Yes.

It's storing data in a temporary storage called buffer.

It's storing data temporarily.

Okay.

Let's.

You said it's storing data temporarily.

And then while transferring the data from last page to another.

I mean.

This definition could actually be applied to other areas also.

It's a it's a very generic response.

Then I can see what you mean to say.

But then this is not a unique characteristics of what buffering means.

Anybody would like to add to what Namu said?

Anyone else?

What is the buffering?

It's like pre-loading data.

And like allow me to play like in the future.

Yeah.

Like pre-loading part of video.

In future means like if you want to play tomorrow like that.

Like if you lose connection, the video can still load because it was pre loaded.

Yeah.

Right.

You're you're very close.

Anyone else want to add anything more to what Alexandra said.

Sorry.

I'm just naming you through the voice.

I cannot see who is talking.

But I hope I'm naming correctly.

Was it Alexandra?

Anyone else?

Is it one like the computer fetches more things in the queue when I put them on hold to do other things first?

No, that's a different thing.

That's a different thing what you said.

That's called scheduling task scheduling that it's putting something on hold.

And in that meanwhile, it is doing something else.

That is actually interrupt handling what you said.

We're talking about buffering.

I think Alexandra was more.

Yeah.

We mean in the case of temporary storing memory in between two places.

No.

No.

Not done.

What do you what comes to mind when you say, oh, I have a slow internet connection and my video is getting buffered.

What is the meaning of that?

I'm watching your video.

A long time to load.

It takes.

It takes more time to load is not exactly buffering.

I mean, it could be indirectly related to buffering, but buffering is something else.

Sorry.

The video.

Yes, again, in the video.

Is it preloading data?

Yeah, it's it's kind of preloading data.

Is it like doing data on like a high speed memory location, something?

No, no.

It's not like storing data on a high.

No, no.

Okay.

So see buffering is when does buffering happens buffering happens when you are trying to retrieve some information beyond the capacity or the resources that you currently have.

Let me repeat.

You're trying to retrieve information beyond the capacity of your computer.

That is when the buffering happens.

For example, you may have let's say one MBPS internet speed bandwidth, but the video that you're playing on the YouTube is high definition, which may let's say required two MB per second of internet speed.

Now, in that case, there are two options.

One is that it plays for a second stops again plays for a second stops again plays for a second because it is not able to meet the requirements of the bandwidth.

So it has to it has to pause and play pause and play, but that will be that will look very, you know, disturbing that your video is not playing smoothly.

So instead of playing and pausing at regular intervals, what's system will do?

It will pause it for a while and it will try to retrieve information for at least next 10 to 15 seconds.

Okay.

Once it has 15 seconds of content that then it will play.

So you get uninterrupted play of the video at least for 15 seconds.

And then in during those 15 seconds, it's also fetching the video content for next 15 seconds.

So it tries to minimize the interruption while you are playing the video.

That is what is called buffering.

That means temporarily storing the data.

Okay.

To make the user's experience more convenient or more less interrupted.

That is when the buffering happens.

Right.

The next one is interrupt handling.

What is interrupt handling?

It's a signal to how to start current process.

Yeah, correct.

Whenever the CPU is trying to process something and it says that the device is not functioning or there's a defect in the device.

Or it requires some inputs or it requires something to be done, which is not being done.

That is one when the interrupt handler comes into existence.

Any example of interrupt handling?

Like passing a video.

That's playing.

No, that's not interrupt handling because when you're playing a video.

It's not an interrupt unless you're playing a video where speaker is an important component of your computer.

And you're if your speaker is not there, the YouTube will not not play.

That is an interrupt.

But tell me some other example interrupt handling.

Come on.

We have 20 couple of students.

We have about how many?

Like example when your laptop has low charging, it displays a message warning you.

No, that is an alert.

That is not interrupt handling.

That is an alert.

Interrupt handling is when the process is stopped because it needs something which is not there.

Like when the printer runs out of paper.

Very good.

That's one of the best examples.

And whenever you have a question about interrupt handling, which often comes in the exam, they always ask you that support your answer with an example.

So printer running out of papers is one of the best examples for the interrupt handling in the sense that you have given a print command.

But then your printer doesn't have papers.

Now the CPU cannot the operating system cannot hold other applications because the printer is running out of papers.

So it will just throw a message on your screen saying that the please the printer is out of paper.

So please refill.

And then it will just disregard that application temporarily from the primary memory.

And it will give a location to the other applications which are running.

As soon as you feed the paper and you press the print button on the printer.

Can I ask a question?

Can somebody's microphone is on?

Can I ask something?

Wait a minute.

Is this your microphone?

Yes.

Can I have a question?

Yes.

Please ask.

Okay.

Is interrupt handling a type of error handling?

Like if I'm running a piece of code, but I'm trying to reference a program that doesn't exist.

And then it exits.

Yes.

Absolutely.

Absolutely.

The easiest.

Yeah.

Absolutely.

That's a good example.

Any scenario.

Any scenario wherein your program has stopped in the process of expecting something from the user.

That is called interrupt handling.

It could even be that you have written a program to take an input from the user.

And when you run your program.

And let's say you go away from the computer.

Your program will stand still there until you feed some data and press enter key.

Right.

So that is also a kind of interrupt handling that you your computer is expecting you to do something.

But that is not being done in such scenarios.

The system will disregard that application for the time being to make efficient use of the CPU.

Instead of CPU sitting idle that.

Oh, I'm waiting for the data to come.

Then only I can do other work now.

So that is called an interrupt handling with the CPU temporarily disregards that work.

I think that requirement is fulfilled and allocates that time to the other applications.

So if you have given a print command and your printer is out of the paper.

Only when you put the papers back in and you press that go ahead.

That the signal will come back to the CPU and it will allocate printing of paper process.

Till that time, it will consider that work to be a sideline.

So that the memory allocation cannot be done for that.

And CPU time is not allocated.

So the best way to judge about interrupt handling is that is the computer waiting for something as an actionable item.

If that is the case, then that's an interrupt handling.

That's the best way to judge.

Okay.

Then moving on.

So different types of operating system.

What is a CLI command line interface?

Any examples?

I can see that examples are there.

But what is CLI?

What are characteristics of CLI?

So let's use us directly.

Command us.

Okay.

So there are two types of OS.

One is of GUI and one is CUI command user interface or command line interface.

Any which way you can use it.

So what is the difference between GUI and CUI?

So I think the command line interface is like a layer of abstraction that stays inside the terminal.

So you're still interacting through the terminal.

You're like Frank commands.

Whereas a GUI would have like buttons or sliders or something.

Yeah, so see the core principle is that both CUI and GUI operating systems are meant for users to interact with the computer.

Now, how do we interact with it in the graphical format or in the text format?

That is what distinguishes between a command line interface and the graphical user interface.

A command line interface.

For example, in the old days, like when I studied, I have used command line interface.

I have seen when the computers did not have GUI.

The first operating system which came into existence during my school days, which was GUI was Windows 3.1.

You can actually search that was the first time when we saw graphical things on the screen.

And before that, all the computers that we saw, Martin, maybe you can also share your experience.

All the computers that we saw had only this screen available.

And it used to be a black screen with white blinking cursor.

And we used to do all the work writing programs running very small games, everything on the screen.

So everything used to be done using the command line.

My first experience was using those.

This operation, which is the earliest version of what later on became Windows.

Or I'll leave the first and everything to be able to see the instruction.

I'm sure every instruction for the computer needed to be typed was a command.

There was no graphical interface.

You needed to really learn all these commands to be able to see the files execute the programs on and so forth.

Later on, I used the first versions of the Mac, the Mac E2.

And it was similar.

It was just a command line version of it.

Absolutely.

So you can see here that if you get a computer which has this kind of interface where you are able to run your applications only in the command form.

It's also difficult.

I mean, you have to memorize literally every command that you could use.

Right?

Like see, if I want to see the date, the command I type is date.

If I have to see the time, I type the command time.

If you have to copy something, you use a copy command.

If you have to delete something, you use delete command.

If you have to clear screen, it used to be CLR SCR in Windows.

Now it's clear.

So everything would be done.

There was not so many things that we could do with the command line interface.

There was no word processor.

There was no PowerPoint.

And I'm not talking about too long ago.

It was it was the time I'm talking about is maybe 1980s.

The first time I saw Windows based systems was around 1994, 1995.

That's the time when I actually saw the Windows based system for the first time before that it was all command line interface.

So this is one of the like linux or units.

If you use it's very commonly used by the system engineers.

They tend to go on the command line interface to interact with the computer rather than a GUI version.

Can I ask another question?

Yeah.

What's the difference between a command line interface and a terminal user interface?

So CLI versus D1.

So so see in in Mac, we call it a terminal screen.

The command is terminal right in Windows based system.

It is more commonly named as like as Martin said, it was called DOS disk operating system, which is again a command line interface.

But it gives you the flexibility to directly speak to your computer at the lower level.

Right, which gives you more control and more power to actually go into the depth of your hardware, which may not be possible because of abstraction on the GUI.

So any system engineer, for example, if you want to do a low level formatting or you have lost your files, which are to be retrieved back after it is deleted.

The system engineers would generally use the command line interface or the terminal screen in order to go into the depth because that there are certain commands which may not be available in the GUI version.

But they are available on the on the command line interface or on the terminal window, which they use in order to write the commands and get the work done.

So it's a more it gives more more control on your computer, but then you need to be knowledgeable in order to make efficient use of the command lines.

If you know the commands, then only it's useful to use them otherwise you will struggle, but essentially there is absolutely no difference between using a terminal window or using a command line interface.

The terminal window is just a name on that every command that you write is actually a command line interface.

That's it.

Mister, I have a question.

Yeah.

So did the people switch to like GUI because like the command line could entangle like those type of programs.

Yes, and also to make it more user friendly.

Now think about somebody whom you give a computer which can only do this.

Like like think about your grandfather.

OK, you have given him a computer that OK, I'm giving good.

I'm gifting you a laptop and this is what they see.

Will they be able to do even slightest of things into into this even let's say it supports let's say word in a different way where everything comes in the black and white screen.

Will they be able to handle it or if you give them a GUI version with a mouse.

At least they will be able to run the mouse go to a particular icon click it right.

They want to play a video that if you have the icon of video available, they can double click and open it.

So the shift from command line interface to the graphical user interface was mainly for the convenience of the users so that people people can start using things more conveniently.

And then was also many different types of applications, which was only possible in the GUI.

I wouldn't say that on the command line interface, we did not have the ways to type a document like how we do in word, but not with so many features.

Like we had something called text editor, which is still there in the in the windows day.

It's called notepad and here it is called text editor where it's not very user friendly, but at least you can do some work into it.

So this was possible even in the command line interface.

You can't do much with the font size, you can't do much with the images, but at least you can type a letter and you can take a print.

But then the shift was taking into account the changing needs of the people to make computers use expanded to different variety of people for different kind of tasks.

And that is why they were shipped from this to that and this is an ongoing process.

It never stopped there because even after the GUI, we have the third type, which is touch interface.

So we have the command line interface, we have the GUI and then now we have the touch interface.

So the new operating systems gives you the flexibility to use your fingers to tap on the icons or do many different things like on your mobile phones, some laptops or the tabs.

And even this is not the end in future, you never know.

I mean, there has been already in use a few operating systems, which can use a laser to project the screen in front of you virtual screen and you're able to type and do all those things.

So this is how the technology in ham sing and we cannot actually predict what kind of systems we will have five years from now.

So depending on our use, the way we have started using technology, things are evolving and they will continue to evolve you a time will come when you will not actually literally need to carry a laptop.

Probably you can create a virtual screen right in front of you from your smartwatch and you can type and do everything.

So this is how things are changing depending on how we have started using technology and what more features we are looking forward to have in the way we use the computer systems.

So far, these are commonly used.

I mean, see why nobody uses now, honestly, except for the system engineers.

GUI is very much in use in all domains, like earlier, even Unix used to be just command line interface and then came the GUI version of Unix and Linux, red hat linux and all that.

Ubuntu, which is an operating system, which is also produced from linux.

It's an extended form of linux, which looks very much like Mac operating system, but it's free.

It's an open source operating system.

We have the touch interface, which is also becoming a little bit popular, not so much also retouch interface, which is used by the mobile devices and later we may have virtual screens also coming up very soon.

So this is the best advantage.

Then instead of typing commands, like in the command line interface, you literally have to type the command copy, see colon slash folder name slash file name, space destination decolon slash.

So you have to literally type the whole command to move one file from one folder to another folder, but not so simple.

You drag and drop and it goes everything, but it's not that we cannot do all these commands still.

If you're using a windows laptop, you can you can go to the run and write cmd there cmd is the command you can actually try when you click on start and run right cmd and enter it will give you that black screen, which will look like this.

cmd that will give you this kind of screen where you can type actually the commands, like copy.

If you want to go to the root folder CD slash DIR will give you the list of directories.

So you can still try that on the windows platform, but generally we don't use it because we have better option in the form of graphical user interface abstraction of hardware.

This we have already talked about that it hides an essential parts and shows us only the things that we want to see.

And the OS also provides high level APIs application programming interfaces that extracts this complexity.

So which means for example, if you want to read a file, you can just use a command.

It gives you the operating system gives you an extracted function, which you can use in your programming to read the content of a file.

It's all the complexity which goes in the background as to how it is doing the indexing how it is reading the file that is all hidden.

So one of the features of operating system is to give you an API for your program wherein you can use those extracted modules in order to get your work done without going into the details.

So examples of modern operating system.

So we have PCs where we are Microsoft Windows Apple Mac OS X linux multipurpose GUI based mobile devices.

We have Android.

We have windows also.

I don't think it's available anymore Android is there iOS is there touch optimized power efficient.

The servers when it comes to servers.

There are trusted trusted server operating systems.

For example, windows servers or linux linux is very common in most of the organizations where they are concerned about the safety and security of the documents.

And also at the same time give them convenient way of communicating with each other within the network linux is very popular in that windows is also good, but then windows is prone to as you know viruses and other kind of attacks.

So most of the organizations they depend on the linux design for performance and scalability embedded systems real time operating systems use in IoT devices.

For example, cars medical instruments etc.

So we will study about embedded system as a full unit that time will talk little more about how the embedded system works what they are what are the benefits of embedded systems etc.

But essentially these are the different types of computers that actually uses different kind of operating systems.

Now, here is a table which may be used by self reading as to what are the different components which are managed by the OS and in what different ways.

For example, operating system manages CPU for scheduling and process control, which means running multiple apps together simultaneously.

It does the memory management, it does the storage management, for example, file organization and TFS FAT etc.

It manages the devices and it gives you an interface where you are able to run your own applications on the operating system resource.

So this again repeat of the same thing.

And these are the questions.

Functions of operating system memory management we have just talked about so this is just a further reading of that.

The OS loads the program from secondary storage like SSD or HDD into the RAM.

It divides memory into different sections which are called pages and within those pages the information is told so that multiple applications can run simultaneously.

As programs run the OS re-allocates and free memory dynamically.

So since the size of memory is static, it cannot hold n number of programs.

So it is the role of the operating system to do proper memory management in the sense that if some application is already completed.

It will remove that application from the memory so that space can be freed up for other applications to run.

Also if it sees that there is some application which is running but it is in the passive mode which the user is not currently running.

Probably in order to accommodate other applications it will push that from primary memory and keep it temporarily in the virtual space.

Because it has to keep the memory free as much as possible for the active programs.

So if I have my so many tabs open which I have not opened for last one week probably then it will push those into the virtual memory and free up that space.

But those applications are not yet closed it will continue to remain there as soon as I click on them it will bring it into the active active mode.

So this is whole this is all the work which computer operating system does in order to make efficient use of the computer system.

This keeps the computer running through server slower and storage access is slower than RAM.

We have RAM which we have done in the previous chapter which is main memory fast virtual memory which is made in the hard drive in order to substitute not substitute in order to work as an add on to the existing primary memory.

And this is slow because it is in the hard disk but it is used only when it is needed otherwise it doesn't use that is an extension to the primary memory.

File management so it does the file management it the operating system helps to read write rename copy and delete files those are some of the basic file operations which are done.

It maintains a hierarchical structure for example you can have a main folder within that main folder you can have sub folders and within the sub folders you can have further sub folders.

So this hierarchy is completely maintained by the computer system.

It shows unique file naming and managing extension so within a folder if you have a file with the name ABC dot DUX you cannot create another file with the same name within the same folder.

So that is taken care those checks are taken care by the operating system you can have the file name same file name in another folder but not within the same folder.

It also maintains the extensions for each file so if you're save a dog file it will give us give it the extension DOC or DOC X image file JPEG or any executable file and windows as EXC.

It also controls the access permissions like I can make a file read only and I can share that with you but you will not be able to make any editing so those things are also taken care by the operating system.

This is a very important feature of operating system does anyone know what is the fragmentation.

I think it's because when a computer stores a file or something it stores each byte or each couple of bytes into a separate memory address and then when you de fragment it kind of brings that data closer and like to close memory addresses so it's easier to find.

So what happens when we studied about the hard disk you you learned about the rotating magnetic disk and there was a head so if you're trying to write it some data and let's say it is writing currently one MP data.

So wherever the head strikes it will write the first 10 MP data one MP there then the next one MP can go somewhere else so that mean all the files are scattered so when you look at the disk structure you will have all data scattered here and there very unorganized way.

Now that makes very difficult for the hardest to find the empty space because it may be rotating very fast when it is trying to write something it will see this already has some data because everything is scattered.

So deep fragmentation is a process of bringing all the scattered data together into one side so that a large part of the secondary storage device can be a vacated.

So it's just a reorganization of data to bring everything together so that a chunk of data can be brought together and the other space can be freed up so it will be faster for the head to find a space where the data can be written.

For example this could be a scattered data everything is just all scattered but when you run the deep fragmentation it will bring the data together so that the space will be freed up for example this one so you can see here this white area in this figure that is resulted after the deep fragmentation so it will try to bring together all the data so that some space can be freed up.

This is all scattered but after the defragmentation you can see that the chunk of data has gone on the top and there is a free space on the bottom this is what the defragmentation is it doesn't do it automatically you will have to run the defragmentation command in order to bring the data to a specific place.

So create rename move copy defragmentation these are the parts of operating system device management we already mentioned that we need to have device drivers for the operating system to recognize it buffering cash spooling plug and play this we already know it would be good if you can go through this reading.

Now scheduling is a very important topic scheduling is nothing different than what we have been talking about that when you're running multiple programs then the system has to find a way to accommodate all of them.

So one of the ways is to create a queue or processes waiting for the CPU time if I look at CPU time using algorithms like first come first serve round robin etc so depending on what kind of queue or processing algorithm that you are writing.

You can actually run a particular algorithm depending on the nature of project or program or how the operating system is meant to operate.

Now first come first service like if you are done applications running let's a printer.

So you have given the first print command and there are three more people who are waiting in the queue and if your printer is meant to be running on first come first serve only after the first person's job is released that the second person will get a chance.

But in other case you may have the flexibility to change the sequence that even the first person gave the first command but you can have a feature in the printer where you bring other tasks up higher on the order so that that print spurts.

So depending on the algorithm you can actually have which how it is executed round robin is something where equal amount of time is given to let's say there are 10 processes running.

It will give some amount of time to one then to two then three then all the way to 10 again it will come back to one so it will be doing in a round robin method but the processing speed is generally so fast that it doesn't take much time.

Obviously it cannot run in the printers that it will print half the page and then give to another half no these are kind of processes for example applications where round robin can be done which balances performance responsiveness and fairness.

Security management this is another way important feature of operating system can you give me some ways that system provides you security I mean any example where you see operating system giving you giving you some security features.

When you run on it when you run on application.

The OS provides virtual space for it's.

That's a different thing altogether that's a storage management.

Yes, some of the operating systems for example windows defender it comes pre loaded with windows unfortunately math doesn't have any such thing.

At least I don't know about that but windows has windows defender which actually protects your computer from it's like a firewall for you computer right any other example of security that your operating system provides will enter class in next 10 minutes so if you can state it will be good.

Any other example of security that your operating system provides.

That's also the encrypt certain personal information which it will not it will not encrypt on its own and it's not the feature of operating system to encrypt that will require another application which can run on your OS OS in itself does not encrypt information.

Any other example.

Also, there's like certain batteries with like such folders and windows that no one's allowed to like access or modify because they're so important so it's like lock behind the password.

That is again an additional application.

I don't think windows in itself provides a feature where you can actually you can hide a folder.

You can hide definitely can hide a folder which will not be visible to others but I have not used windows for a very long time.

But I don't know if new windows if that feature is there but I don't think you can make password protected using operating system features.

You can have third party applications which can help you to password protect your folders but I don't think it comes by default with windows.

No, I meant like if you access like a system 32 folder then it's not password protected.

It's just like that you can't access it because it's like a user.

Okay fine so any of the windows related files and folders they are protected by the system so that accidentally if you delete it then it will completely crash your computer because OS is gone.

So that's a kind of way it's not I mean I would say that it's a safety for the users.

I'm more particular about how is your computer protecting the safety and security of the data that you have on the computer system.

Any other example.

The use firewalls and other viruses or like security systems to check for like malware.

But that is again a third party apps like in windows.

I know that there's windows defender but on Mac I don't think there's any so you can install third party Mac has something to end up like security system.

Like it says like even install an app for them from the internet they will check it.

Yeah you're right so Mac has that system where when you try to download something from the third party apps and you try to install it then it stops it until you go to the settings and you actually activate that I'm allowing third party apps to be installed very good.

That's a good example of the protection of your computer from possibility of viruses.

Yeah that's a good example.

Another example is for example let's say when you start your computer do you get that screen where you have to type the password to go further into the operating system.

It says shows your username right and then you have to type your password correct.

Yes isn't it so there you can have biometric there you can have type password or many different ways of login into the system.

That is the feature of operating system which actually is meant to protect your data so that unauthorized people cannot get access to your computer.

So those are that is how the computer provides you with the security so that is called authentication confirms identity.

It could be IR I guess it could be I mean the webcam related the authentication it can be biometric which you have on your Mac and windows.

It can be typed password any which ways.

Sir there is also that thing that when you're downloading something it shows a message which says.

This could harm your computer it would be easier to your computer correctly you correct that yeah yeah absolutely so that alert is coming from the operating system when it recognizes that you are trying to download something which may have malicious.

Component for example a virus or malware it alerts that yeah that's also one of the features of operating system that is able to alert you.

Accounting the OS keeps track of how systems resources are used by the users and processes.

So that's another thing.

So this this topic is not so difficult because it's more of learning unlike the previous topics that we started where it was logic gates and calculations and came up this is more about self reading.

I'm sure that if you go through this document you will easily understand what the features are of operating system so we are going from one to seven or eight but for the from the exam point of view you will even if you.

If you are proficient with two to three features of operating system I think that will be good and unless they ask you very specific question that how does computer manage memory for multiple tasks processing then you have to talk about the memory management but otherwise if they just say that identify three features of operating system you can just pick up anything.

Virtualization and networking allowing multiple virtual machines to run on one physical stream and this is becoming quite common in today's time like you learned about this in the previous topics.

Infrastructure as a service that uses virtualization so it splits the CPU power into many different parts and each application can use that part of CPU as if it is using full potential of the CPU.

That is the virtualization and this is becoming quite common because the speed of computer is going higher and higher so why not the CPU power can be split virtually into many parts so that it can process more data that is what is called virtualization.

For example running windows and linux simultaneously on Mac using software like parallel parallettes or VMware so there are a lot of virtualization applications available nowadays for example some of you may have used Android virtual machine on your Mac like if you are trying to do some sort of mobile applications development you can have virtualization of your mobile operating system on your phone on your laptop so that you get the Android screen on your mobile on your laptop.

Those are the virtualization that when using your CPU resources in such a way that it is running to or more unidentical system unidentical systems simultaneously.

Network connections so you are able to connect for example if you are trying to share files between two maps you can use a drop right so those kind of networking related features are provided by the operating system.

The scheduling approaches I think it will be not possible today because this is an important topic and I want to give it some time so probably we will take up this topic in the next week because we have to go a little bit into details and it will be good if you can come in fact I have to add more content to this about the scheduling because this is very important topic and you can definitely expect some questions coming in from this as to how does paging works.

What are the different ways that the scheduling is done by the computer system right so I will add little more content to it and probably will cover it in the next class.

All right in the meantime before we meet for the next class I will share with you some instructions about how to install netbeams and JDK on your computer so just follow those steps and try to install it yourself if you are stuck or if you are not able to do.

Then probably we'll solve it next time so in order to understand your systems better I will share a Google Doc with you where you can mention which.

Operating system you are using with a Mac or windows okay and if it is Mac or windows and which version of windows you are using which you can find from here go to the Apple symbol and click on system sorry.

Go to about this Mac and you can copy it is data from here like minus chip Apple M4 so similarly you may also have some mac OS.

So put that into the Google Doc so that I will see that what are different versions you will be needing for your netbeams and JDK is a little complicated process in the beginning especially for the Mac but once it is installed then it will be convenient.

So let's try and complete this over the next couple of days so that you all are ready with the apps installed on your machine when we start with the programming.

All right so that's it for today's class is anybody who has not yet filled the utterness if not I'm putting the link again so that you can.

Fill the utterness in the meantime if you have any questions feel free to ask.

Martin sorry you wanted to add anything further.

Your mute your muted Martin.

Just just to make sure that next class we take a few minutes to revisit the K maps as we said earlier yeah sure yes in addition with with maybe whatever questions they might have if they try to install netbeams or JDK that's it absolutely yeah.

I will review and revise the K map logic gate diagrams truth table and simplification of Boolean expressions using the Boolean laws these are the four things that we will cover in the next class I kept it for today but I'm sure it will not be possible today.

Does anyone have any questions.

Is there about the Python and Java.

Yeah right so see IP has given the flexibility for students to use anything between Python and Java but we at Pamoja have decided to go ahead with Java because it provides better.

Features to not only learn object oriented approaches but also from the I point of view right and in terms of complexity it might Python might look little easy at this stage but then actually let me tell you.

That from the examinations point of view the level of complexity requirement will be absolutely same between Java and Python which means the question paper will very explicitly say explicitly say that don't use job Python functions right so therefore we as a group have decided to go ahead with Java and if you have already done Python that will be an added advantage because most of the syntax is between Python and Java they are similar.

I have a question regarding the I.A.

We are expected to start it in November.

Yeah let me see if I have the timeline.

Yeah we want to start early because we want to finish early and computer science I.A.s are much more difficult than other subjects this is not to scare you but that's a reality and we have to accept that it's much more difficult than other subject it's very time consuming so we want to start early so that it doesn't run for a very long time so.

Yes so we essentially we start I.A.

on have a shade my screen.

So we start introduction to I.A.

on 5th of November and then you will make your proposals in the next week.

Then you will get a feedback about your proposal and then we'll introduce you criteria A and B of the I.A.

So I would strongly recommend that you should start thinking about what kind of project that you will develop.

Probably next week we'll talk about what could be the possible projects in the computer science I.A.

So that you can start thinking about what you would like to develop.

So 26 November introduction to our criteria A and B and then your criteria A and B will be due by February 18th.

Sorry by 11th of February criteria B and A which does not require programming skills until this point.

You don't need any programming skills it's more about designing.

This is the point from where your programming will be started from the second February 18th of February.

So introduction to I.A.

criteria C which is about the coding of your product no sorry see in the new in the new I.A.

Criteria C is also documentation so this is even here you don't need programming skills until here.

So criteria C is done in April 25th April.

This is where your programming will start.

9th of September introduction to I.A.

criteria D.

So this is where your programming will start that is the next year when when the term starts.

And then you have criteria D first draft in November because this is where you will be coding the product.

And then these are easy ones criteria is very easy that will take just about a day or two to complete.

So this is essentially the plan we want to finish I.A.

by January 27th of January.

No not 24 January sorry by 24th of February everything is to be finished because after this you will have the mock exams.

So we want to finish everything before mock.

Now ask your question this was the calendar.

What was the question related to I.A.

What is the question that what is the calendar look like?

Yeah that was the question.

Thomas.

I was just wondering about what knowledge is expected.

We haven't had that on computer science.

Yeah so that's a good question.

So computer science I.A.

is the solution developed using any of the computer tools which showcases your algorithmic thinking skills.

So it has to be a coding based solution which could be anything.

For example, let's you make an interactive quiz system where you have a dashboard where the questions are popping up.

You choose the answer and it creates a profile as to what is your competency level right.

So you have to think about any problem which could easily be solved using technology and then you have to develop a product for that.

So generally it's a GUI program.

I have couple of samples I can show you next week or otherwise week after next when we'll introduce the I.A.

But essentially it's a it's a it's a GUI application which is to be developed using any of the tools.

So if you're good at programming, even if you are never done programming, it doesn't mean that you cannot develop them because it's more about designing a system and running some SQL advanced in the background for the transaction of data back and forth.

So don't worry about that.

We will teach you a few mini projects which will help you to understand what should be there.

How the project is to be developed.

So just say I'm not a big way this is signed by the idea of what your project and the thing behind it or more than your coding skills and complexity of it.

So there used to be complexity in the previous guide but now they have removed the term complexity.

It is justification of what techniques you have used to solve a problem.

Okay, it should have a genuine it should have an authentic.

I mean, let me put it this way that you're developing something not just for the sake of developing, but you're justifying why this product could be beneficial to somewhat.

So as long as there's a justification to the solution that you have developed, it will be considered to be an appropriate I.A.

In the previous guide, it used to be a complexity that you have to show how your project is very complex, which to me doesn't make any sense because then students putting the complexity unnecessarily, which is not even needed.

So now they have removed the complexity term and I just about justification of how you think that this project will have some significance or some relevance from the users point of view.

Also now there is no need of client in the previous guide.

You had to find a client who is struggling to run their their business and then you would develop something for them, but now it's completely your choice.

What you want to develop and even if it is not meant for anybody else, it's perfectly fine.

You can develop something for yourself also.

Maybe your question is done.

Yeah, that was the question that I had.

It's something that I can, that only addresses a specific issue that I have I can make.

That was just the question I had.

Okay, no, you can develop something for your own use also.

Like you want to make an expense tracking system, right?

Your father gives you money every month and then you have to manage your budget because you have to show it to your father month end of the month.

How you spend the money that was given to you, right?

So you can create a expense tracking system for yourself.

That's it.

Any other question?

Do we need to use the specific program specified by the I.B.

No, no, no.

No, no.

No, no.

I.B.

It does not specify any program.

The choice of program can be completely yours.

For example, you may end up making a game using unity.

Which could be a product which may be beneficial to let's say primary school students to learn mathematics.

So it can be completely your choice what you want to use.

Okay.

Yeah, I.B.

Is that complex and real?

Yeah, you can use any application, but you have to show the algorithmic thinking.

It's not just drag and drop that you ended up making a fancy game just by dragging and dropping the gadgets.

Or applying physics, which is all inbuilt into the game development tool.

That will not fit your score.

You have to show the coding that you have done to make that work.

Abdul.

I wanted to confirm so basically our I.A.

Will be a program that we write to solve a problem in the Java language.

No, that's what I'm saying.

It can be any language.

It can be Java.

It can be Python.

It can be.

It can be visual basic.

It can be PHP.

It can be HTML anything that you feel like using.

We should have a potential usage.

Whatever you develop that would have a potential usage.

But majority of students choose net Java in the front end and SQL in the back end.

But you are not restricted to that.

I mean you can use anything probably next week.

I'll show you one sample project which was developed in php and my as well.

That could be seen as one sample.

But you don't really have to develop in the same way.

Next.

Okay.

We were basically learning Java for the I.A.

Or will it have some other use in the syllabus?

No.

No, we are learning Java to meet the paper to requirements from the I.D.

Point of view.

And we are learning Java.

So that you become eligible to pursue computer science in the university.

Just in case if you want to study computer science.

Right.

So it's not just for I.A.

It can be it can be helpful in your I.A.

But the core objective is not I.A.

Because Java may not necessarily be used for your I.A.

You may use something else.

It's mainly for paper to.

Okay.

Thank you, sir.

You're welcome.

Any other question, guys?

All good?

Okay.

So.

Yeah.

Yeah.

Please.

Go ahead.

The first phase.

What.

Are there.

A.

What will you do now?

Sorry.

Say again.

I didn't get your question.

At.

At a part of the I.A.

What.

Yeah.

Yeah.

Okay.

Okay.

So see.

When I say I.A.

I.A.

I.A.

Right.

I.A.

I.A.

I.A.

I.A.

I.A.

I.A.

I.A.

Our.

I.A.

A.

In the end product which you will write using some programming language.

It's not just that.

It's the whole design cycle.

So criteria.

A is problem specification, which means what is the problem that you are trying to solve?

So you will write it in two paragraphs, going to develop, you will identify the major parts of that project, that is called decomposition, which will study in B, B1, the computational thinking, data composition, the algorithm, the abstraction, all that will be part of section B.

But anyway, for criteria B, you are decomposing the system, that means you are dividing your larger system into many different achievable parts.

Criteria C is designing the system.

For example, how your screen will look like.

So you will use some UI designs, software to design.

My login screen will look like this.

My dashboard will look like this.

Okay.

And then also the algorithm or the flowcharts as to how your system will work.

That is criteria C.

Criteria D is actual development of the product and then showcasing in about thousand words, how your product is working, like how your login screen is working.

So you will show the screenshot of login screen from your actual product.

You will show the code of this area in your project where it is doing the login part.

Right.

So the functionality of your product in the written format in about thousand words, that is criteria D.

Criteria and also the video.

So you will record a five minute screencast of your product, like you will you will run your project and you will do a screencast.

So that will also go in criteria D.

So it has two components.

One is the 1000 words explanation to your project and one is the five minute video.

And criteria E is the future evaluation.

I mean the evaluation and future recommendations.

You will judge what are the components that you were able to achieve and what are the areas you were not able to achieve and how you can make your product better in the future.

So that goes in the criteria E.

So collectively all these criteria contribute to the score of 30 out of which it will be decided what grade you get into.

So just having, just having, just having complete.

Sorry Thomas.

What's the question?

We'll all that be achievable when the curriculum that we have learned during the time we're doing this.

So we'll part A, B, B and C.

We are the information already have.

Yes.

A, B and C.

All three will be achievable by the information that we have so far.

So no programming knowledge is needed.

No.

In Criteria C algorithm, the some part of Criteria C you can do, but there is something called like flow charts that we haven't learned yet.

So flow chart part you will have to learn.

Then data dictionary like what your database will look like that we haven't done yet.

So that's why the dates are split in such a way that by the time we reach to that level, you will already have done that content part to meet the requirements of that particular that particular criteria.

Okay.

But then the what is most essential is that you should start working on the programming.

If you haven't done it before just to develop the algorithmic technique skills and just to learn the basics of how the programs work.

So go to the W3 schools and start learning Java if you haven't done already.

And for learning on that platform, you don't really need netbeams or JD to install.

You can run it online on that same portal.

Abdul, you have one more question?

All right.

Okay.

So if there are no more questions, then you may leave now.

And we'll meet next week to discuss further on the course.

Stay engaged.

I know there's a lot of content at least at this moment.

Some of the chapters are very content heavy.

And theme A chapter one is one of them.

Then if we go a little lighter as we proceed.

Database chapters would be an interesting one where you will learn the SQL commands, how the tables are made, how the data is stored, how the data is retrieved.

That is more hands-on.

You will enjoy that network will again be a little theoretical chapter and same with the machine learning.

But then we have split it in such a way that we have the mix of programming and theory, so it will both will go simultaneously.

So after this unit, we are going to jump on to the computational thinking topic and the programming program development, which you will find interesting, I'm sure.

All right, guys.

So if no other questions, we are done with the class.

Can I have the questions?

You're welcome, software.

Good.

Bye, everyone.

Hi.

Hi, guys.

Bye, bye, everyone.

You asked your question before U.S.D.

Yeah, yeah, I see.

Some of the, like, on my assignment review thingy, you wrote that I haven't completed all my questions.

Yeah, yeah, yeah.

I just want to know where that is.

I will go.

I will check that I answered all the questions.

I don't understand how I didn't answer all the questions.

Yours is the one where you made all the drawings on same page, right?

With the pencil.

All the logic.

Did you use pen and pencil to draw?

Yeah, so that may have kind of got mixed up.

I will have a look at it again to see maybe I miss interpreted because all the all the logic diagrams are made on the same page.

Probably the question numbers may have been mixed or something.

So I will look at that again.

Don't worry.

Yeah, I tried to like organize this.

So it's easy to understand.

Yeah, sure.

I can come back to that because I was kind of surprised, it's like kind of like see my grade and then they kind of wanted to know how I can move on the next.

Yeah, that's right.

So next time onwards, don't use the same page to draw so many drawing, so many images, you know, just draw one after another in a sequential order of the questions so that it's easier for us to understand.

I think I did.

I just like.

Was it your one image per question?

No, not one image per question.

Was it your work or somebody else where you had about six or seven logic diagrams on one page, one besides another, like that format?

Was it yours or somebody else?

It's okay.

I will go through your work again.

I'm see if I missed any question.

I will regraded and updated in the score sheet.

Okay, thank you.

All right.

Yeah, I was wondering where you sent the links for the videos because I did have them.

I just can't seem to find them right now.

Okay, so you don't have the, you're in HL or SL, I'm HL.

So for HL, you don't have to go to the folder to view the videos, what you can do is within the canvas itself.

Let me share my screen.

I'll show you.

So within the, I don't know if I can go to that page now.

When you go to the online classes, there's the online classes link, right?

I'm on your canvas platform.

We have an on, okay, I think I can show you.

Yeah, I can see ideas.

When you go to the online classroom and then go to the main class.

Yeah.

And in the main class, there's a recording tab on the right.

So when you click on the recording, it will show you all past recordings and you can directly it just says there are no recordings for this meeting.

Are you looking, are you looking into a main class?

Yes.

See, here is the recording tab.

See, what do you have to do is?

So when you go to the online class, you may see one class with the name main class.

And when you go to the main class, there is this recording tab and within recording tab, you have all the previous recordings available.

Like today's recording is still going on, so it will be available in an hour or so from now.

Okay, I will let you know if I so I'm able to find it later on.

Thank you so much.

Or you can, or you can share your screen.

I can show you right away.

Okay, how do I share my screen?

On the top.

Okay, once I can I'll give you the right.

Can you see here?

Okay.

Can you see my keyboard?

Not yet.

It may take some time to load.

Once I can.

You click on share and then entire screen and then click on that window and then share.

I don't think it works.

When you click on share, okay, maybe you're using my, is it asking me?

No, I think it's yeah, the permissions.

I don't have any.

Okay, no problem.

So you try that in the recording folders, but we'll also share with you one link in your email using which you can access the folder also.

Okay, thank you so much, sir, for your time.

No problem.

You're welcome.

Also, you Mr.

Martin.

Thank you.

Bye.

Bye.

Have a good day.

Thank you.

Yeah.

Same to you.

No, no, you can leave.

I was talking to you, Aiza.

Aiza, you have a question?

No, that's it.

I was the one talking.

I don't think you okay.

Okay.

Okay.

Sorry.

I thought it was.

Okay, Aiza.

Fine.

All right.

Bye.

Bye.

I have a good speaker.

Bye.

Bye.

Bye.

Bye.

Okay, Martin.

Thank you.

We'll, I think next week is the last one before the break for the turn break, right?

You're muted.

How are you feeling?

I mean, for me, it's been a very taxing semester in my school and everything that I'm doing, you know.

I know.

Yeah, it takes a lot of efforts, but that's life.

True.

Thank you for clarifying the questions about the gradients and everything, because the kids really were, I got like four emails from, from my SL kids, because but I'm, I'm, yeah, we still have no a lot of attendance, you know.

We have like maybe 30% of attendance.

We have like 60% students and we only get like, you have to identify those students and then reach out to the SPC's.

At least they should know that some students are not attending.

Yeah.

All right.

Well, Raj, thank you for everything, man.

Okay.

Oh, you're welcome.

Thank you for being there, Martin.

Seriously, I mean, we don't have to be there for each class, both of us.

Once it is settled, then maybe we'll split between us like one week, you can go next week, I can go.

So like that, you know, so yeah, we'll, we'll, we'll meet and then discuss what's the best sure.

Okay.

Okay.

Okay.

All right.

They can't have a good rest of the weekend.

Bye.

Same to you.

Bye.

Bye.

