[← Back to Week 2 Overview](./2.0.md)

# Week 2 Lesson 5 — Fetch-Decode-Execute Cycle and CPU–Memory Buses

## Learning Objectives
- Understand how a CPU executes a machine-language instruction.
- Describe interaction between memory and registers via address, data, and control buses.

## Introduction to the Fetch-Decode-Execute Cycle
Three steps by which a CPU processes instructions:
1. Fetch: PC address -> memory via Address Bus; instruction to IR via Data Bus.
2. Decode: CU interprets opcode and operands; sets control signals.
3. Execute: ALU and CPU components perform operation; results stored in register or memory.

This cycle repeats continuously while programs run.

## Diagram
![Fetch-Decode-Execute Cycle](https://pamojaeducation.instructure.com/courses/339/files/24229/download)

## Step-by-Step Breakdown
- Fetch Stage:
  - PC holds next instruction address
  - Address Bus to RAM; IR stores instruction; PC increments
- Decode Stage:
  - CU reads IR; extracts opcode/operands; prepares control signals
- Execute Stage:
  - ALU/units execute; may fetch/store data; write result to register/memory

## Memory–Register Interaction via Three Buses
1. Address Bus: PC places address; MAR holds it; goes to memory/I-O
2. Data Bus: MDR transfers data/instructions to IR or registers; writes back results
3. Control Bus: CU read/write and control signals coordinate transfers

## Summary
- The cycle enables sequential processing.
- CPU uses address, data, and control buses to interact with memory/registers.
- Continuous repetition is essential for program execution.

## Further Exploration
- Research pipelining and its effect on the cycle.
- Compare single-core vs modern multi-core implementations.
- Note findings in your learning journal.
