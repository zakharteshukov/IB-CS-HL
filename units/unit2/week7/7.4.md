[← Back to Week 7 Overview](./7.0.md)

# Translators: Interpreters, Compilers, JIT, Bytecode

## Learning Objectives
- Compare interpreters, compilers, JIT, and bytecode interpreters
- Analyze mechanics, advantages, trade‑offs
- Choose methods for speed, iteration, portability

---

## Approaches and Mechanics
1) Interpreters: execute source line‑by‑line; great for rapid iteration/debugging (e.g., Python, JS);
   slower runtime.
2) Compilers: translate whole program to native binary; faster execution; ideal for performance‑critical
   software (e.g., C/C++); more complex debug cycle.
3) JIT Compilation: compile at runtime; optimizes hot paths; balances flexibility and speed (e.g., JVM, CLR);
   may impact startup.
4) Bytecode Interpreters: compile to portable bytecode for a VM (e.g., JVM, Python PVM); portable, often
   faster than pure interpretation; may add runtime overhead.

---

## Comparison (Key Ideas)

| Feature | Interpreter | Compiler | JIT | Bytecode |
|---|---|---|---|---|
| Error detection | Runtime | Compile‑time | Runtime with opt | Both |
| Translation time | None pre‑run; slower exec | One‑time; faster exec | Runtime compile of hot code | Pre‑to‑bytecode; mid performance |
| Portability | Platform‑dependent | Platform‑dependent | Platform‑dependent, optimized | Highly portable |
| Use cases | Prototyping, scripting | Performance‑critical | Mixed workload | Cross‑platform |

---

## Choosing Methods: Scenarios
- Rapid development/testing → Interpreter (fast iteration)
- Performance‑critical/real‑time → Compiler or JIT (speed/opt)
- Cross‑platform targets → Bytecode or JIT on VM (portability + speed)

---

## Interactive Decision Game
External tool: choose translator per scenario and justify
`https://pamojaeducation.instructure.com/courses/339/external_tools/retrieve?display=borderless&resource_link_lookup_uuid=5c58e3d2-de45-4f60-be5a-0d103d4e8484`

---

## Conclusion
Pick translation based on iteration needs, performance constraints, and portability requirements.
