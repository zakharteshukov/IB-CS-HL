[â† Back to Week 4 Overview](./4.0.md)

# Week 4 Lesson 1 â€” Binary and Hexadecimal (Integers and Conversions)

## Learning Objectives
- Understand representation of integers in binary and hexadecimal
- Convert between binary/hexadecimal and decimal (both directions)
- Convert between binary and hexadecimal

## Why Binary and Hex?
- Binary (baseâ€‘2) uses 0/1 for efficient digital hardware
- Hex (baseâ€‘16) is a compact, humanâ€‘readable form of binary (1 hex digit = 4 bits)

## Binary vs Hex (Overview)
| Feature | Binary (Baseâ€‘2) | Hexadecimal (Baseâ€‘16) |
|---|---|---|
| Explanation | Fundamental internal representation (bits, powers of 2) | Compact humanâ€‘readable form, digits 0â€“9 and Aâ€“F |
| Number of digits | Longer representation | Shorter representation |
| Used for | Internal processing | Memory addressing, color codes, compact values |
| Example (47â‚â‚€) | 101111â‚‚ | 2Fâ‚â‚† |

## Realâ€‘World Examples
- Color codes: `#FF0000` (pure red)
- IPv6 addressing: `2001:0db8:85a3::8a2e:0370:7334`
- Memory addresses: `0x1C3`

## Visuals
![](Pasted%20image%2020251101191502.png)
## Conversions
- Binary â†’ Decimal: sum of bit Ã— 2â¿
- Decimal â†’ Binary: repeated division by 2 (collect remainders, bottomâ€‘toâ€‘top)
- Hex â†’ Decimal: sum of digit Ã— 16â¿
- Decimal â†’ Hex: repeated division by 16 (collect remainders)
- Binary â†” Hex: group bits in 4s, map to hex digit

## Worked Example (Decimal 47)
- Binary: 47 = 101111â‚‚ = (1Ã—2âµ)+(0Ã—2â´)+(1Ã—2Â³)+(1Ã—2Â²)+(1Ã—2Â¹)+(1Ã—2â°)
- Hex: 47 = 2Fâ‚â‚† = (2Ã—16Â¹)+(15Ã—16â°)

## Practice Videos
- Understanding Binary and Hexadecimal Number Systems â€” https://www.youtube.com/watch?v=thrx3SBEpL8
- Binary, Decimal, and Hexadecimal Conversions Explained â€” https://www.youtube.com/watch?v=LpuPe81bc2w
- Hexadecimal and Binary Conversion Tutorial â€” https://www.youtube.com/watch?v=yewlVSik_Iw

## Further Reading
- Number Systems in Computing â€” https://www.geeksforgeeks.org/number-system-and-base-conversions/
- Number Systems and Conversions â€” https://www.tutorialspoint.com/basics_of_computers/basics_of_computers_number_system_conversion.htm

## Key Points
- Binary and hex are essential for computer representation and readability
- Use powers of 2 (binary) and powers of 16 (hex) for conversions
- Group 4 bits â†” 1 hex digit for quick conversion

---

# ðŸ“ IB Examination-Style Question Bank

*Practice questions designed to prepare for IB CS HL Papers 1, 2, and 3*

---

## Paper 1 Style - Multiple Choice

### Question 1: Define - [1 mark] ðŸŸ¢

**ðŸ“Š Status:** 
- [x] Completed 
- [x] Correct 
- [ ] Challenging 

What is the hexadecimal equivalent of the binary number 11010111â‚‚?

A. D7â‚â‚†  
B. 2A7â‚â‚†  
C. 215â‚â‚†  
D. C9â‚â‚†

> [!success]- Answer
> **Correct Answer: A**
> 
> **Explanation:**
> To convert binary to hexadecimal, group bits into groups of 4 from right to left: 1101 0111. 1101â‚‚ = 13â‚â‚€ = Dâ‚â‚†, and 0111â‚‚ = 7â‚â‚€ = 7â‚â‚†. Therefore, 11010111â‚‚ = D7â‚â‚†.
> 
> **Mark Scheme:**
> - Correct answer A identified [1 mark]

---

### Question 2: Identify - [1 mark] ðŸŸ¢

**ðŸ“Š Status:** 
- [x] Completed 
- [x] Correct 
- [ ] Challenging

Which of the following best explains why hexadecimal is commonly used in computing instead of binary for displaying memory addresses?

A. Hexadecimal uses fewer digits than binary for the same value  
B. Hexadecimal is easier to convert to decimal  
C. Hexadecimal allows representation of larger numbers  
D. Hexadecimal is the native format computers use internally

> [!success]- Answer
> **Correct Answer: A**
> 
> **Explanation:**
> Hexadecimal uses base-16, meaning each hex digit represents 4 bits. This makes hex representations much more compact than binary (e.g., FFâ‚â‚† = 11111111â‚‚). Memory addresses can be very long in binary, but hex provides a human-readable shorthand. Computers still use binary internally; hex is just a convenient display format.
> 
> **Mark Scheme:**
> - Correct answer A identified [1 mark]

---

### Question 3: Calculate - [1 mark] ðŸŸ¡

**ðŸ“Š Status:** 
- [ ] Completed 
- [ ] Correct 
- [ ] Challenging

Convert the decimal number 186â‚â‚€ to hexadecimal. Show your working.

A. BAâ‚â‚†  
B. 11Aâ‚â‚†  
C. B6â‚â‚†  
D. 186â‚â‚†

> [!success]- Answer
> **Correct Answer: A**
> 
> **Explanation:**
> Using repeated division by 16:
> - 186 Ã· 16 = 11 remainder 10 (A in hex)
> - 11 Ã· 16 = 0 remainder 11 (B in hex)
> Reading remainders bottom to top: BAâ‚â‚†
> Verification: (BÃ—16Â¹) + (AÃ—16â°) = (11Ã—16) + (10Ã—1) = 176 + 10 = 186 âœ“
> 
> **Mark Scheme:**
> - Correct answer A identified [1 mark]

---

### Question 4: State - [1 mark] ðŸŸ¢

**ðŸ“Š Status:** 
- [x] Completed 
- [x] Correct 
- [ ] Challenging

What is the maximum decimal value that can be represented using 8 bits in binary?

A. 127  
B. 255  
C. 256  
D. 512

> [!success]- Answer
> **Correct Answer: B**
> 
> **Explanation:**
> With 8 bits, there are 2â¸ = 256 possible combinations. Since we start counting from 0, the maximum value is 2â¸ - 1 = 255.
> 
> **Mark Scheme:**
> - Correct answer B identified [1 mark]

---

## Paper 2 Style - Structured Questions

### Question 5: Calculate - [4 marks] ðŸŸ¡

**ðŸ“Š Status:** 
- [ ] Completed 
- [ ] Correct 
- [ ] Challenging

A programmer is debugging code and encounters the memory address 0x3B8F in hexadecimal.

(a) Convert 0x3B8F to decimal, showing your method clearly. [2 marks]

(b) Convert the same value to binary, showing your working. [2 marks]

> [!success]- Answer
> **Answer:**
> 
> **(a) Hexadecimal to Decimal:**
> 
> 0x3B8F = 3B8Fâ‚â‚†
> 
> Using place values: (3Ã—16Â³) + (BÃ—16Â²) + (8Ã—16Â¹) + (FÃ—16â°)
> 
> = (3Ã—4096) + (11Ã—256) + (8Ã—16) + (15Ã—1)
> 
> = 12288 + 2816 + 128 + 15
> 
> = 15247â‚â‚€
> 
> **(b) Hexadecimal to Binary:**
> 
> Convert each hex digit to 4-bit binary:
> 
> 3â‚â‚† = 0011â‚‚
> 
> Bâ‚â‚† (11â‚â‚€) = 1011â‚‚
> 
> 8â‚â‚† = 1000â‚‚
> 
> Fâ‚â‚† (15â‚â‚€) = 1111â‚‚
> 
> Therefore: 3B8Fâ‚â‚† = 0011101110001111â‚‚ = 111011110001111â‚‚ (can drop leading zeros)
> 
> **Mark Scheme:**
> - **(a)** Correct identification of hex digits and conversion (3=3, B=11, 8=8, F=15) [1 mark]
> - Correct calculation with place values and final answer 15247â‚â‚€ [1 mark]
> - **(b)** Correct conversion of each hex digit to 4-bit binary [1 mark]
> - Correct combination of binary digits with proper formatting [1 mark]
> - **Total: 4 marks**

---

### Question 6: Explain - [6 marks] ðŸŸ¡

**ðŸ“Š Status:** 
- [ ] Completed 
- [ ] Correct 
- [ ] Challenging

The color code #A5C3E8 is used in a web application for a background color.

(a) Explain what each component of this hexadecimal color code represents. [2 marks]

(b) Convert the red component (A5) to both binary and decimal, showing your working. [2 marks]

(c) Explain why hexadecimal is preferred over binary for representing color codes in web development. [2 marks]

> [!success]- Answer
> **Answer:**
> 
> **(a) Color Code Components:**
> 
> The hexadecimal color code #A5C3E8 represents RGB (Red, Green, Blue) values:
> - A5â‚â‚† is the red component
> - C3â‚â‚† is the green component
> - E8â‚â‚† is the blue component
> 
> Each component is 8 bits (1 byte), allowing 256 possible intensity levels (0-255 in decimal) per color channel.
> 
> **(b) Red Component Conversion:**
> 
> **Hexadecimal to Decimal:**
> A5â‚â‚† = (AÃ—16Â¹) + (5Ã—16â°) = (10Ã—16) + (5Ã—1) = 160 + 5 = 165â‚â‚€
> 
> **Hexadecimal to Binary:**
> Aâ‚â‚† = 10â‚â‚€ = 1010â‚‚
> 5â‚â‚† = 5â‚â‚€ = 0101â‚‚
> 
> A5â‚â‚† = 10100101â‚‚
> 
> **(c) Advantages of Hexadecimal:**
> 
> Hexadecimal is preferred because:
> - **Compactness**: Each hex digit represents 4 bits, so A5â‚â‚† is more readable than 10100101â‚‚. Color codes like #A5C3E8 use only 6 hex digits vs 24 binary digits.
> - **Human readability**: Easier to identify patterns and make quick adjustments (e.g., making a color lighter by incrementing hex values).
> - **Standard convention**: Web standards (CSS, HTML) use hex notation, making it industry-standard for web development.
> - **Error reduction**: Shorter representation reduces typos compared to long binary strings.
> 
> **Mark Scheme:**
> - **(a)** Explanation that code represents RGB components [1 mark]
> - Identification that each component is 8 bits/1 byte [1 mark]
> - **(b)** Correct decimal conversion of A5 to 165 [1 mark]
> - Correct binary conversion to 10100101â‚‚ [1 mark]
> - **(c)** At least one valid advantage (compactness, readability, convention) explained [1 mark]
> - Second advantage clearly explained [1 mark]
> - **Total: 6 marks**

---

### Question 7: Compare - [5 marks] ðŸŸ¡

**ðŸ“Š Status:** 
- [ ] Completed 
- [ ] Correct 
- [ ] Challenging

Compare and contrast binary and hexadecimal number systems in terms of their use in computing.

> [!success]- Answer
> **Answer:**
> 
> **Similarities:**
> - Both are positional number systems that use powers of their base (binary: powers of 2, hexadecimal: powers of 16)
> - Both can represent any integer value
> - Both are used in computing contexts, though for different purposes
> - Both use discrete digits (binary: 0-1, hexadecimal: 0-9, A-F)
> 
> **Differences:**
> 
> **Binary:**
> - Base-2 system, fundamental to digital electronics (maps directly to on/off states)
> - Uses only two digits (0 and 1)
> - Longer representation for the same value (e.g., 255â‚â‚€ = 11111111â‚‚ uses 8 digits)
> - Used internally by computers for all data processing and storage
> - Directly represents bit patterns in hardware
> 
> **Hexadecimal:**
> - Base-16 system, derived from binary for human convenience
> - Uses 16 digits (0-9, A-F)
> - Much more compact representation (e.g., 255â‚â‚€ = FFâ‚â‚† uses only 2 digits)
> - Used primarily for human-readable display (memory addresses, color codes, debugging)
> - Each hex digit represents exactly 4 bits, making conversion straightforward
> - Commonly used in programming and documentation
> 
> **Use Cases:**
> - Binary: Internal computer operations, bit manipulation, low-level programming
> - Hexadecimal: Memory addressing (0x prefix), color codes (#RRGGBB), IPv6 addresses, debugging memory dumps
> 
> **Mark Scheme:**
> - Identification of at least one similarity [1 mark]
> - Clear comparison showing binary as base-2, hex as base-16 [1 mark]
> - Explanation of binary's direct hardware mapping [1 mark]
> - Explanation of hex's compactness and human readability [1 mark]
> - Appropriate use case examples for each system [1 mark]
> - **Total: 5 marks**

---

### Question 8: Calculate - [3 marks] ðŸŸ¢

**ðŸ“Š Status:** 
- [ ] Completed 
- [ ] Correct 
- [ ] Challenging

Convert the binary number 1010110101â‚‚ to hexadecimal using the grouping method.

> [!success]- Answer
> **Answer:**
> 
> Group bits from right to left in groups of 4:
> 
> 10 1011 0101
> 
> (Note: leftmost group may have fewer than 4 bits - pad with leading zeros if needed, but here 10 is fine as 2 bits)
> 
> Converting each group:
> - 10â‚‚ = 2â‚â‚€ = 2â‚â‚†
> - 1011â‚‚ = 8+2+1 = 11â‚â‚€ = Bâ‚â‚†
> - 0101â‚‚ = 4+1 = 5â‚â‚€ = 5â‚â‚†
> 
> Therefore: 1010110101â‚‚ = 2B5â‚â‚†
> 
> **Alternative (with padding):**
> 0010 1011 0101 = 2B5â‚â‚†
> 
> **Mark Scheme:**
> - Correct grouping into 4-bit chunks [1 mark]
> - Correct conversion of each group to hex digit [1 mark]
> - Correct final answer 2B5â‚â‚† [1 mark]
> - **Total: 3 marks**

---

### Question 9: Explain - [4 marks] ðŸŸ¡

**ðŸ“Š Status:** 
- [ ] Completed 
- [ ] Correct 
- [ ] Challenging

A network administrator is configuring an IPv6 address and sees the value `2001:0db8:85a3::8a2e:0370:7334`.

Explain why hexadecimal notation is used for IPv6 addresses rather than decimal or binary notation.

> [!success]- Answer
> **Answer:**
> 
> **Hexadecimal Advantages for IPv6:**
> 
> IPv6 addresses are 128 bits long, divided into 8 groups of 16 bits (hextets) separated by colons.
> 
> **Why Hexadecimal:**
> 1. **Compact representation**: Each hex digit represents 4 bits. A 16-bit hextet requires only 4 hex digits (e.g., 0db8) compared to 16 binary digits (0000110110111000). Using decimal would also be longer and less intuitive.
> 
> 2. **Easy bit manipulation**: Since hex maps directly to binary (1 hex digit = 4 bits), network administrators can easily identify subnet boundaries and perform bitwise operations without converting to binary first.
> 
> 3. **Readability**: IPv6 addresses are already long; using binary would make them extremely difficult to read and type (128 binary digits vs 32 hex digits).
> 
> 4. **Standard convention**: The IPv6 specification uses hexadecimal as the standard format, ensuring consistency across documentation and tools.
> 
> 5. **Error reduction**: Shorter hex representation reduces typos and makes addresses easier to verify.
> 
> **Comparison:**
> - Binary: 128 digits - impractical for human use
> - Decimal: Would work but less intuitive for bit operations
> - Hexadecimal: Optimal balance between compactness and readability
> 
> **Mark Scheme:**
> - Explanation of hex compactness (fewer digits than binary) [1 mark]
> - Reference to IPv6 length (128 bits) and practical implications [1 mark]
> - Explanation of ease of bit manipulation with hex [1 mark]
> - Additional valid reason (readability, convention, error reduction) [1 mark]
> - **Total: 4 marks**

---

### Question 10: Calculate - [5 marks] ðŸŸ¡

**ðŸ“Š Status:** 
- [ ] Completed 
- [ ] Correct 
- [ ] Challenging

Perform the following conversions, showing all working:

(a) Convert 349â‚â‚€ to binary using repeated division. [2 marks]

(b) Convert the binary result from part (a) to hexadecimal. [2 marks]

(c) Verify your answer by converting the hexadecimal result directly back to decimal. [1 mark]

> [!success]- Answer
> **Answer:**
> 
> **(a) Decimal to Binary (Repeated Division by 2):**
> 
> 349 Ã· 2 = 174 remainder 1  
> 174 Ã· 2 = 87 remainder 0  
> 87 Ã· 2 = 43 remainder 1  
> 43 Ã· 2 = 21 remainder 1  
> 21 Ã· 2 = 10 remainder 1  
> 10 Ã· 2 = 5 remainder 0  
> 5 Ã· 2 = 2 remainder 1  
> 2 Ã· 2 = 1 remainder 0  
> 1 Ã· 2 = 0 remainder 1
> 
> Reading remainders from bottom to top: 101011101â‚‚
> 
> Verification: 1Ã—2â¸ + 0Ã—2â· + 1Ã—2â¶ + 0Ã—2âµ + 1Ã—2â´ + 1Ã—2Â³ + 1Ã—2Â² + 0Ã—2Â¹ + 1Ã—2â°
> = 256 + 64 + 16 + 8 + 4 + 1 = 349 âœ“
> 
> **(b) Binary to Hexadecimal:**
> 
> Group 101011101â‚‚ into groups of 4 from right: 1 0101 1101
> 
> 1â‚‚ = 1â‚â‚† (or pad: 0001â‚‚ = 1â‚â‚†)  
> 0101â‚‚ = 5â‚â‚†  
> 1101â‚‚ = 8+4+1 = 13â‚â‚€ = Dâ‚â‚†
> 
> Therefore: 101011101â‚‚ = 15Dâ‚â‚†
> 
> **(c) Hexadecimal to Decimal Verification:**
> 
> 15Dâ‚â‚† = (1Ã—16Â²) + (5Ã—16Â¹) + (DÃ—16â°)
> = (1Ã—256) + (5Ã—16) + (13Ã—1)
> = 256 + 80 + 13
> = 349â‚â‚€ âœ“
> 
> **Mark Scheme:**
> - **(a)** Correct repeated division showing all steps [1 mark]
> - Correct binary answer 101011101â‚‚ [1 mark]
> - **(b)** Correct grouping and conversion to hex [1 mark]
> - Correct hex answer 15Dâ‚â‚† [1 mark]
> - **(c)** Correct verification calculation back to 349â‚â‚€ [1 mark]
> - **Total: 5 marks**

---

## Extended Response Questions

### Question 11: Evaluate - [8 marks] ðŸ”´

**ðŸ“Š Status:** 
- [ ] Completed 
- [ ] Correct 
- [ ] Challenging

Evaluate the advantages and disadvantages of using hexadecimal representation compared to binary representation for displaying memory addresses in debugging and programming contexts.

> [!success]- Answer
> **Answer:**
> 
> **Advantages of Hexadecimal:**
> 
> 1. **Compactness and Readability**
>    - Memory addresses are typically 32 or 64 bits. A 32-bit address in binary requires 32 digits (e.g., 10101101001011101100011101011011â‚‚), while hex requires only 8 digits (e.g., AD2E C75Bâ‚â‚†). This dramatic reduction makes addresses much easier to read and remember.
>    - Programmers can quickly scan hex addresses to identify patterns or spot errors.
> 
> 2. **Easy Binary Conversion**
>    - Each hex digit directly maps to 4 bits, making mental conversion simple. For example, Eâ‚â‚† = 1110â‚‚ can be quickly recognized.
>    - This is useful when debugging requires understanding bit-level operations.
> 
> 3. **Industry Standard**
>    - Hexadecimal is the universal convention for memory addresses (0x prefix in C/C++, debuggers, documentation). Using hex ensures consistency across tools and team communication.
> 
> 4. **Error Reduction**
>    - Shorter representations reduce transcription errors when manually copying addresses or reading documentation.
> 
> 5. **Alignment Recognition**
>    - Hex makes it easier to identify memory alignment (e.g., addresses ending in 0 are aligned to 16-byte boundaries).
> 
> **Disadvantages of Hexadecimal:**
> 
> 1. **Indirect Representation**
>    - Computers store addresses in binary internally. Hex is an intermediate representation, so understanding actual bit patterns requires mental conversion or lookup tables.
> 
> 2. **Learning Curve**
>    - New programmers must learn hex digits (A-F) and their decimal equivalents, adding initial cognitive load.
> 
> 3. **Conversion Overhead**
>    - For bitwise operations, hex may require conversion to binary first, though this is typically straightforward.
> 
> 4. **Not Native Format**
>    - Hex doesn't directly show individual bit states, which can be important for flag fields or bit masks.
> 
> **Conclusion:**
> 
> For debugging and programming, hexadecimal's advantages significantly outweigh its disadvantages. The compactness, readability, and industry standard make it essential for practical software development. While binary is needed for understanding hardware-level details, hex serves as the optimal bridge between human readability and machine representation.
> 
> **Mark Scheme:**
> - At least two clear advantages explained with examples [3 marks]
> - At least one disadvantage identified and explained [2 marks]
> - Context-specific evaluation (debugging/programming scenarios) [2 marks]
> - Balanced conclusion with justified recommendation [1 mark]
> - **Total: 8 marks**

---

### Question 12: Analyze - [7 marks] ðŸ”´

**ðŸ“Š Status:** 
- [ ] Completed 
- [ ] Correct 
- [ ] Challenging

A student claims that "hexadecimal is just a shortcut for binary and serves no other purpose." Analyze this statement, providing evidence to support or refute the claim.

> [!success]- Answer
> **Answer:**
> 
> **Analysis:**
> 
> The statement contains partial truth but oversimplifies hexadecimal's role in computing. While hex is indeed a more compact representation of binary, it serves multiple critical purposes beyond being a "shortcut."
> 
> **Supporting Evidence (Why it's a "shortcut"):**
> 
> - Hexadecimal does provide a compact way to represent binary values. Each hex digit represents exactly 4 bits, reducing digit count by 75% (e.g., FFâ‚â‚† vs 11111111â‚‚).
> - It's a derived notation that doesn't change the underlying binary data.
> - Computers internally process data in binary, not hexadecimal.
> 
> **Refuting Evidence (Beyond just a shortcut):**
> 
> 1. **Human Cognitive Benefits:**
>    - Hex isn't just shorter; it's structured to align with common byte boundaries (8 bits = 2 hex digits), making mental arithmetic and pattern recognition significantly easier.
>    - The base-16 system aligns with powers of 2, creating natural groupings that match how computers organize data.
> 
> 2. **Industry Standard and Communication:**
>    - Hexadecimal has become the de facto standard for memory addresses, color codes, and debugging output. This standardization enables effective communication between developers, tools, and documentation.
>    - Standardization reduces errors and training costs.
> 
> 3. **Practical Applications:**
>    - **Memory Addressing**: Hex makes it easy to identify address alignment and calculate offsets (e.g., addresses ending in 0 are 16-byte aligned).
>    - **Color Codes**: Web colors use hex (#RRGGBB) because it's intuitive for designers to increment values (e.g., #FF0000 to #FF0800 makes red slightly greener).
>    - **Networking**: IPv6 uses hex for compact, readable 128-bit addresses.
> 
> 4. **Error Prevention:**
>    - The compactness isn't just convenienceâ€”it directly reduces transcription errors and makes manual verification feasible.
> 
> 5. **Mathematical Convenience:**
>    - Hex digits align with nibble (4-bit) boundaries, making binary operations mentally manageable. For example, bitwise AND with 0xF0 clearly shows we're working with the high nibble.
> 
> **Conclusion:**
> 
> While hexadecimal is fundamentally a compact binary representation, calling it "just a shortcut" undervalues its role as a practical tool that enhances human-computer interaction. It's better described as an "optimized notation system" that serves cognitive, practical, and communication needs beyond simple brevity.
> 
> **Mark Scheme:**
> - Recognition that hex is a compact binary representation [1 mark]
> - Identification that it serves purposes beyond being a shortcut [1 mark]
> - At least two specific examples of practical applications [2 marks]
> - Analysis of cognitive/communication benefits [2 marks]
> - Balanced conclusion evaluating the statement [1 mark]
> - **Total: 7 marks**

---

### Question 13: Calculate and Explain - [6 marks] ðŸŸ¡

**ðŸ“Š Status:** 
- [ ] Completed 
- [ ] Correct 
- [ ] Challenging

A computer uses 16-bit memory addresses.

(a) Calculate the maximum number of memory locations that can be addressed using 16 bits. Show your working. [2 marks]

(b) Express this maximum address in both hexadecimal and binary. [2 marks]

(c) Explain why a computer scientist might choose to display this maximum address in hexadecimal rather than binary when documenting memory specifications. [2 marks]

> [!success]- Answer
> **Answer:**
> 
> **(a) Maximum Memory Locations:**
> 
> With 16 bits, there are 2Â¹â¶ possible combinations.
> 
> 2Â¹â¶ = 65,536 different memory locations
> 
> This represents the addressable memory space (each location can hold typically 1 byte).
> 
> **(b) Maximum Address Representation:**
> 
> The maximum 16-bit value is when all bits are 1:
> 
> **Binary**: 1111111111111111â‚‚ (16 ones)
> 
> **Hexadecimal**: Convert by grouping: 1111 1111 1111 1111
> - Each 1111â‚‚ = 15â‚â‚€ = Fâ‚â‚†
> - Therefore: FFFFâ‚â‚†
> 
> **(c) Why Hexadecimal for Documentation:**
> 
> Hexadecimal is preferred for documentation because:
> 
> 1. **Compactness**: FFFFâ‚â‚† uses only 4 characters compared to 16 binary digits. This makes documentation cleaner, easier to read, and takes less space.
> 
> 2. **Industry Standard**: Memory addresses are universally documented in hexadecimal (often with 0x prefix like 0xFFFF), so using hex maintains consistency with technical specifications, data sheets, and programming documentation.
> 
> 3. **Pattern Recognition**: Hex makes it easy to identify special addresses (e.g., FFFFâ‚â‚† is clearly the maximum, 0000â‚â‚† is the minimum). Binary strings are harder to scan for patterns.
> 
> 4. **Error Reduction**: Fewer characters mean fewer opportunities for transcription errors when copying addresses between documents or systems.
> 
> **Mark Scheme:**
> - **(a)** Correct calculation 2Â¹â¶ = 65,536 with working [2 marks]
> - **(b)** Correct binary 1111111111111111â‚‚ [1 mark]
> - Correct hexadecimal FFFFâ‚â‚† [1 mark]
> - **(c)** At least two valid reasons (compactness, standard, readability, error reduction) [2 marks]
> - **Total: 6 marks**

---

## Paper 3 Style - Case Study Application

### Question 14: Scenario-Based - [10 marks] ðŸ”´

**ðŸ“Š Status:** 
- [ ] Completed 
- [ ] Correct 
- [ ] Challenging

A software development team is debugging a memory corruption issue. During investigation, they encounter the following memory dump showing addresses and data in hexadecimal:

```
Address    Data
0x00401000 48 65 6C 6C 6F
0x00401005 20 57 6F 72 6C 64
0x0040100B 21 00 00 00
```

The team notices that memory addresses increment in a specific pattern and data values are displayed in two-digit hexadecimal format.

(a) Explain why the memory addresses are displayed in hexadecimal format rather than binary or decimal. [3 marks]

(b) Convert the data at address 0x00401000 to its ASCII character representation, showing how you determined each character. [3 marks]

(c) A junior programmer suggests converting all hexadecimal values to decimal for "easier understanding." Evaluate this suggestion, considering both advantages and disadvantages. [4 marks]

> [!success]- Answer
> **Answer:**
> 
> **(a) Why Hexadecimal for Memory Addresses:**
> 
> Memory addresses are displayed in hexadecimal for several critical reasons:
> 
> 1. **Compactness**: Memory addresses are typically 32 or 64 bits. In binary, a 32-bit address like 0x00401000 would be 00000000010000000001000000000000â‚‚ (32 digits), while hex requires only 8 characters. This dramatic reduction makes addresses readable and manageable.
> 
> 2. **Byte Alignment Recognition**: Hex addresses make it easy to identify byte boundaries and alignment. Addresses ending in 0 are aligned to 16-byte boundaries, which is important for understanding memory layout and performance.
> 
> 3. **Industry Standard**: Hexadecimal is the universal convention in debugging tools, documentation, and programming. Using hex ensures consistency across tools (debuggers, disassemblers, hex editors) and team communication.
> 
> 4. **Easy Binary Conversion**: Each hex digit represents 4 bits, making it straightforward to convert to binary when needed for bitwise operations or understanding flag fields.
> 
> 5. **Pattern Recognition**: Hex makes it easier to spot patterns, calculate offsets, and perform mental arithmetic on addresses.
> 
> **(b) ASCII Conversion:**
> 
> Convert each hex byte to decimal, then to ASCII:
> 
> 0x00401000: 48 65 6C 6C 6F
> 
> - 48â‚â‚† = (4Ã—16) + 8 = 64 + 8 = 72â‚â‚€ â†’ ASCII 72 = 'H'
> - 65â‚â‚† = (6Ã—16) + 5 = 96 + 5 = 101â‚â‚€ â†’ ASCII 101 = 'e'
> - 6Câ‚â‚† = (6Ã—16) + 12 = 96 + 12 = 108â‚â‚€ â†’ ASCII 108 = 'l'
> - 6Câ‚â‚† = (6Ã—16) + 12 = 108â‚â‚€ â†’ ASCII 108 = 'l'
> - 6Fâ‚â‚† = (6Ã—16) + 15 = 96 + 15 = 111â‚â‚€ â†’ ASCII 111 = 'o'
> 
> Therefore: "Hello"
> 
> **(c) Evaluation of Decimal Conversion:**
> 
> **Advantages of Decimal:**
> 
> 1. **Familiarity**: Junior programmers may find decimal more intuitive since it's the number system used daily. This could reduce initial learning curve.
> 
> 2. **Direct Comparison**: Decimal allows direct comparison with array indices or sizes that might be specified in decimal (e.g., "array of 1024 elements").
> 
> **Disadvantages of Decimal:**
> 
> 1. **Loss of Byte Boundaries**: Decimal doesn't naturally show byte boundaries. In hex, each pair of digits represents a byte, making it easy to see data structure. Decimal obscures this relationship.
> 
> 2. **Conversion Complexity**: Converting hex to decimal requires calculation, while hex to binary is straightforward (each digit = 4 bits). When debugging, you often need binary understanding for bit flags or bitwise operations.
> 
> 3. **Industry Standard**: All debugging tools, documentation, and experienced developers use hexadecimal. Converting to decimal would create inconsistency and make collaboration difficult.
> 
> 4. **Memory Alignment**: Hex makes alignment patterns obvious (addresses ending in 0, 4, 8, C are naturally aligned). This is much harder to see in decimal.
> 
> 5. **Pattern Recognition**: Hex patterns are easier to recognize (e.g., repeating values, sequential addresses). Decimal doesn't preserve these visual patterns.
> 
> 6. **Longer Representation**: Large addresses in decimal are longer and harder to read (e.g., 0x00401000 = 4,194,304 in decimal).
> 
> **Conclusion:**
> 
> While decimal might feel more familiar initially, hexadecimal is essential for professional software development. The disadvantages significantly outweigh the advantages. Instead of converting to decimal, junior programmers should learn hexadecimalâ€”it's a fundamental skill that becomes intuitive with practice and is required throughout their career.
> 
> **Recommendation:**
> 
> Maintain hexadecimal format but provide training/support to help junior programmers understand hex-to-decimal conversion when needed for comprehension.
> 
> **Mark Scheme:**
> - **(a)** At least two valid reasons for hex addresses explained [2 marks]
> - Additional reason or depth of explanation [1 mark]
> - **(b)** Correct conversion of at least 3 hex bytes to ASCII [2 marks]
> - Correct identification of "Hello" string [1 mark]
> - **(c)** At least one advantage of decimal identified [1 mark]
> - At least two clear disadvantages explained [2 marks]
> - Balanced evaluation with conclusion [1 mark]
> - **Total: 10 marks**

---

### Question 15: Application - [9 marks] ðŸ”´

**ðŸ“Š Status:** 
- [ ] Completed 
- [ ] Correct 
- [ ] Challenging

A graphics designer is working with a digital image editor and needs to understand how colors are represented. The software displays color values in hexadecimal format (e.g., #RRGGBB where RR = red, GG = green, BB = blue, each ranging from 00â‚â‚† to FFâ‚â‚†).

(a) Calculate the decimal value of the green component in the color code #3A7F2C. Show your working. [2 marks]

(b) Explain how many different color combinations can be represented using this 24-bit RGB color model. Show your calculation. [3 marks]

(c) A designer wants to create a color that is exactly halfway between pure red (#FF0000) and pure green (#00FF00) by averaging the hex values. Evaluate whether simply averaging the hexadecimal digits will produce the correct result, and explain your reasoning. [4 marks]

> [!success]- Answer
> **Answer:**
> 
> **(a) Green Component Calculation:**
> 
> In #3A7F2C, the green component is 7F (the middle pair).
> 
> 7Fâ‚â‚† to decimal:
> 7Fâ‚â‚† = (7Ã—16Â¹) + (FÃ—16â°)
> = (7Ã—16) + (15Ã—1)
> = 112 + 15
> = 127â‚â‚€
> 
> Therefore, the green intensity is 127 out of 255 (50% of maximum).
> 
> **(b) Total Color Combinations:**
> 
> The 24-bit RGB model uses:
> - 8 bits for red (2â¸ = 256 possible values: 0-255)
> - 8 bits for green (2â¸ = 256 possible values: 0-255)
> - 8 bits for blue (2â¸ = 256 possible values: 0-255)
> 
> Total combinations = 256 Ã— 256 Ã— 256
> = 2â¸ Ã— 2â¸ Ã— 2â¸
> = 2Â²â´
> = 16,777,216 different colors
> 
> This is approximately 16.7 million colors, often called "true color" or 24-bit color depth.
> 
> **(c) Evaluation of Averaging Hex Digits:**
> 
> **Incorrect Method (Averaging Hex Digits Directly):**
> 
> If we average hex digits directly:
> - Red: #FF 00 00
> - Green: #00 FF 00
> - Average: #(F+0)/2 (F+0)/2 (F+0)/2 ...
> 
> This doesn't work mathematically because hex digits represent positional values, not linear values. Averaging hex digits treats them as if each digit has equal weight, which is incorrect.
> 
> **Correct Method (Convert to Decimal, Average, Convert Back):**
> 
> 1. Convert to decimal:
>    - Pure Red: FFâ‚â‚† = 255â‚â‚€, 00â‚â‚† = 0â‚â‚€, 00â‚â‚† = 0â‚â‚€ â†’ RGB(255, 0, 0)
>    - Pure Green: 00â‚â‚† = 0â‚â‚€, FFâ‚â‚† = 255â‚â‚€, 00â‚â‚† = 0â‚â‚€ â†’ RGB(0, 255, 0)
> \
> 2. Average in decimal:
>    - Red: (255 + 0) / 2 = 127.5 â‰ˆ 128â‚â‚€
>    - Green: (0 + 255) / 2 = 127.5 â‰ˆ 128â‚â‚€
>    - Blue: (0 + 0) / 2 = 0â‚â‚€
> 
> 3. Convert back to hex:
>    - 128â‚â‚€ = 80â‚â‚†
>    - Result: #808000 (yellowish color)
> 
> **Why Direct Hex Averaging Fails:**
> 
> - Hex is positional: FFâ‚â‚† = (15Ã—16) + (15Ã—1) = 255. You can't average the digits separately.
> - Example: Averaging Fâ‚â‚† (15) and 0â‚â‚† (0) gives 7.5, but the actual average of 255 and 0 is 127.5, which in hex is 7Fâ‚â‚† (not 77â‚â‚† if you just averaged digits).
> - Hex digits don't have linear relationshipsâ€”position matters (16s place vs 1s place).
> 
> **Correct Answer:**
> 
> Simply averaging hexadecimal digits will NOT produce the correct result. You must:
> 1. Convert each component to decimal
> 2. Perform arithmetic in decimal (where the values are linear)
> 3. Convert the result back to hexadecimal
> 
> The halfway point between pure red and pure green results in yellow (#808000), which makes sense perceptually (red + green = yellow in additive color mixing).
> 
> **Mark Scheme:**
> - **(a)** Correct identification of green component 7F [1 mark]
> - Correct conversion to 127â‚â‚€ [1 mark]
> - **(b)** Correct identification of 8 bits per channel [1 mark]
> - Correct calculation 256Â³ or 2Â²â´ [1 mark]
> - Correct final answer 16,777,216 [1 mark]
> - **(c)** Recognition that direct hex averaging is incorrect [1 mark]
> - Explanation of why (positional system, non-linear) [1 mark]
> - Correct method shown (decimal conversion â†’ average â†’ hex) [1 mark]
> - Correct result #808000 or equivalent explanation [1 mark]
> - **Total: 9 marks**

---
